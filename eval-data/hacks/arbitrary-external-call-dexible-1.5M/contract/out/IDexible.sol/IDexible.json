{"abi":[{"type":"function","name":"arbitrumGasOracle","inputs":[],"outputs":[{"name":"","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"function","name":"communityVault","inputs":[],"outputs":[{"name":"","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"function","name":"dxblToken","inputs":[],"outputs":[{"name":"","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"function","name":"minBpsRate","inputs":[],"outputs":[{"name":"","type":"uint16","internalType":"uint16"}],"stateMutability":"view"},{"type":"function","name":"minFeeUSD","inputs":[],"outputs":[{"name":"","type":"uint112","internalType":"uint112"}],"stateMutability":"view"},{"type":"function","name":"pause","inputs":[],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"resume","inputs":[],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"revshareSplitRatio","inputs":[],"outputs":[{"name":"","type":"uint8","internalType":"uint8"}],"stateMutability":"view"},{"type":"function","name":"selfSwap","inputs":[{"name":"request","type":"tuple","internalType":"struct SwapTypes.SelfSwap","components":[{"name":"feeToken","type":"address","internalType":"contract IERC20"},{"name":"tokenIn","type":"tuple","internalType":"struct TokenTypes.TokenAmount","components":[{"name":"amount","type":"uint112","internalType":"uint112"},{"name":"token","type":"address","internalType":"contract IERC20"}]},{"name":"tokenOut","type":"tuple","internalType":"struct TokenTypes.TokenAmount","components":[{"name":"amount","type":"uint112","internalType":"uint112"},{"name":"token","type":"address","internalType":"contract IERC20"}]},{"name":"routes","type":"tuple[]","internalType":"struct SwapTypes.RouterRequest[]","components":[{"name":"router","type":"address","internalType":"address"},{"name":"spender","type":"address","internalType":"address"},{"name":"routeAmount","type":"tuple","internalType":"struct TokenTypes.TokenAmount","components":[{"name":"amount","type":"uint112","internalType":"uint112"},{"name":"token","type":"address","internalType":"contract IERC20"}]},{"name":"routerData","type":"bytes","internalType":"bytes"}]}]}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"setArbitrumGasOracle","inputs":[{"name":"oracle","type":"address","internalType":"contract IArbitrumGasOracle"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"setCommunityVault","inputs":[{"name":"vault","type":"address","internalType":"contract ICommunityVault"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"setMinBpsRate","inputs":[{"name":"bps","type":"uint16","internalType":"uint16"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"setMinFeeUSD","inputs":[{"name":"minFee","type":"uint112","internalType":"uint112"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"setRevshareSplitRatio","inputs":[{"name":"bps","type":"uint8","internalType":"uint8"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"setStdBpsRate","inputs":[{"name":"bps","type":"uint16","internalType":"uint16"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"setTreasury","inputs":[{"name":"t","type":"address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"stdBpsRate","inputs":[],"outputs":[{"name":"","type":"uint16","internalType":"uint16"}],"stateMutability":"view"},{"type":"function","name":"swap","inputs":[{"name":"request","type":"tuple","internalType":"struct SwapTypes.SwapRequest","components":[{"name":"executionRequest","type":"tuple","internalType":"struct ExecutionTypes.ExecutionRequest","components":[{"name":"requester","type":"address","internalType":"address"},{"name":"fee","type":"tuple","internalType":"struct ExecutionTypes.FeeDetails","components":[{"name":"feeToken","type":"address","internalType":"contract IERC20"},{"name":"affiliate","type":"address","internalType":"address"},{"name":"affiliatePortion","type":"uint256","internalType":"uint256"}]}]},{"name":"tokenIn","type":"tuple","internalType":"struct TokenTypes.TokenAmount","components":[{"name":"amount","type":"uint112","internalType":"uint112"},{"name":"token","type":"address","internalType":"contract IERC20"}]},{"name":"tokenOut","type":"tuple","internalType":"struct TokenTypes.TokenAmount","components":[{"name":"amount","type":"uint112","internalType":"uint112"},{"name":"token","type":"address","internalType":"contract IERC20"}]},{"name":"routes","type":"tuple[]","internalType":"struct SwapTypes.RouterRequest[]","components":[{"name":"router","type":"address","internalType":"address"},{"name":"spender","type":"address","internalType":"address"},{"name":"routeAmount","type":"tuple","internalType":"struct TokenTypes.TokenAmount","components":[{"name":"amount","type":"uint112","internalType":"uint112"},{"name":"token","type":"address","internalType":"contract IERC20"}]},{"name":"routerData","type":"bytes","internalType":"bytes"}]}]}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"treasury","inputs":[],"outputs":[{"name":"","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"event","name":"AffiliatePaid","inputs":[{"name":"affiliate","type":"address","indexed":true,"internalType":"address"},{"name":"token","type":"address","indexed":false,"internalType":"address"},{"name":"amount","type":"uint256","indexed":false,"internalType":"uint256"}],"anonymous":false},{"type":"event","name":"ArbGasOracleChanged","inputs":[{"name":"newVault","type":"address","indexed":false,"internalType":"address"}],"anonymous":false},{"type":"event","name":"ChangedBpsRates","inputs":[{"name":"stdRate","type":"uint32","indexed":false,"internalType":"uint32"},{"name":"minRate","type":"uint32","indexed":false,"internalType":"uint32"}],"anonymous":false},{"type":"event","name":"ChangedRevshareSplit","inputs":[{"name":"split","type":"uint8","indexed":false,"internalType":"uint8"}],"anonymous":false},{"type":"event","name":"ChangedRevshareVault","inputs":[{"name":"old","type":"address","indexed":true,"internalType":"address"},{"name":"newRevshare","type":"address","indexed":true,"internalType":"address"}],"anonymous":false},{"type":"event","name":"InsufficientGasFunds","inputs":[{"name":"relay","type":"address","indexed":true,"internalType":"address"},{"name":"amount","type":"uint256","indexed":false,"internalType":"uint256"}],"anonymous":false},{"type":"event","name":"MinBpsChanged","inputs":[{"name":"newRate","type":"uint16","indexed":false,"internalType":"uint16"}],"anonymous":false},{"type":"event","name":"MinFeeChanged","inputs":[{"name":"newMin","type":"uint112","indexed":false,"internalType":"uint112"}],"anonymous":false},{"type":"event","name":"PaidGasFunds","inputs":[{"name":"relay","type":"address","indexed":true,"internalType":"address"},{"name":"amount","type":"uint256","indexed":false,"internalType":"uint256"}],"anonymous":false},{"type":"event","name":"Paused","inputs":[],"anonymous":false},{"type":"event","name":"Resumed","inputs":[],"anonymous":false},{"type":"event","name":"SplitRatioChanged","inputs":[{"name":"newRate","type":"uint8","indexed":false,"internalType":"uint8"}],"anonymous":false},{"type":"event","name":"StdBpsChanged","inputs":[{"name":"newRate","type":"uint16","indexed":false,"internalType":"uint16"}],"anonymous":false},{"type":"event","name":"SwapFailed","inputs":[{"name":"trader","type":"address","indexed":true,"internalType":"address"},{"name":"feeToken","type":"address","indexed":false,"internalType":"address"},{"name":"gasFeePaid","type":"uint256","indexed":false,"internalType":"uint256"}],"anonymous":false},{"type":"event","name":"SwapSuccess","inputs":[{"name":"trader","type":"address","indexed":true,"internalType":"address"},{"name":"affiliate","type":"address","indexed":true,"internalType":"address"},{"name":"inputAmount","type":"uint256","indexed":false,"internalType":"uint256"},{"name":"outputAmount","type":"uint256","indexed":false,"internalType":"uint256"},{"name":"feeToken","type":"address","indexed":false,"internalType":"address"},{"name":"gasFee","type":"uint256","indexed":false,"internalType":"uint256"},{"name":"affiliateFee","type":"uint256","indexed":false,"internalType":"uint256"},{"name":"dexibleFee","type":"uint256","indexed":false,"internalType":"uint256"}],"anonymous":false},{"type":"event","name":"TreasuryChanged","inputs":[{"name":"newTreasury","type":"address","indexed":false,"internalType":"address"}],"anonymous":false},{"type":"event","name":"VaultChanged","inputs":[{"name":"newVault","type":"address","indexed":false,"internalType":"address"}],"anonymous":false}],"bytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"deployedBytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"methodIdentifiers":{"arbitrumGasOracle()":"76a13636","communityVault()":"53e97868","dxblToken()":"dd81eb98","minBpsRate()":"370fb45b","minFeeUSD()":"4e0bb8cc","pause()":"8456cb59","resume()":"046f7da2","revshareSplitRatio()":"52ac8616","selfSwap((address,(uint112,address),(uint112,address),(address,address,(uint112,address),bytes)[]))":"c3d718a4","setArbitrumGasOracle(address)":"f3390c3a","setCommunityVault(address)":"d8544cf3","setMinBpsRate(uint16)":"24b40c92","setMinFeeUSD(uint112)":"8c47ea8e","setRevshareSplitRatio(uint8)":"1725d82f","setStdBpsRate(uint16)":"5d745b8f","setTreasury(address)":"f0f44260","stdBpsRate()":"bb471234","swap(((address,(address,address,uint256)),(uint112,address),(uint112,address),(address,address,(uint112,address),bytes)[]))":"602dd026","treasury()":"61d027b3"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"affiliate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AffiliatePaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newVault\",\"type\":\"address\"}],\"name\":\"ArbGasOracleChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"stdRate\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"minRate\",\"type\":\"uint32\"}],\"name\":\"ChangedBpsRates\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"split\",\"type\":\"uint8\"}],\"name\":\"ChangedRevshareSplit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"old\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRevshare\",\"type\":\"address\"}],\"name\":\"ChangedRevshareVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relay\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"InsufficientGasFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"newRate\",\"type\":\"uint16\"}],\"name\":\"MinBpsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint112\",\"name\":\"newMin\",\"type\":\"uint112\"}],\"name\":\"MinFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relay\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PaidGasFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Resumed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"newRate\",\"type\":\"uint8\"}],\"name\":\"SplitRatioChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"newRate\",\"type\":\"uint16\"}],\"name\":\"StdBpsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasFeePaid\",\"type\":\"uint256\"}],\"name\":\"SwapFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"affiliate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"affiliateFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dexibleFee\",\"type\":\"uint256\"}],\"name\":\"SwapSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newTreasury\",\"type\":\"address\"}],\"name\":\"TreasuryChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newVault\",\"type\":\"address\"}],\"name\":\"VaultChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"arbitrumGasOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"communityVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dxblToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minBpsRate\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minFeeUSD\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resume\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revshareSplitRatio\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"feeToken\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint112\",\"name\":\"amount\",\"type\":\"uint112\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct TokenTypes.TokenAmount\",\"name\":\"tokenIn\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint112\",\"name\":\"amount\",\"type\":\"uint112\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct TokenTypes.TokenAmount\",\"name\":\"tokenOut\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint112\",\"name\":\"amount\",\"type\":\"uint112\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct TokenTypes.TokenAmount\",\"name\":\"routeAmount\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"routerData\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapTypes.RouterRequest[]\",\"name\":\"routes\",\"type\":\"tuple[]\"}],\"internalType\":\"struct SwapTypes.SelfSwap\",\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"selfSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IArbitrumGasOracle\",\"name\":\"oracle\",\"type\":\"address\"}],\"name\":\"setArbitrumGasOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICommunityVault\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"setCommunityVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"bps\",\"type\":\"uint16\"}],\"name\":\"setMinBpsRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint112\",\"name\":\"minFee\",\"type\":\"uint112\"}],\"name\":\"setMinFeeUSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"bps\",\"type\":\"uint8\"}],\"name\":\"setRevshareSplitRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"bps\",\"type\":\"uint16\"}],\"name\":\"setStdBpsRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stdBpsRate\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"feeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"affiliate\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"affiliatePortion\",\"type\":\"uint256\"}],\"internalType\":\"struct ExecutionTypes.FeeDetails\",\"name\":\"fee\",\"type\":\"tuple\"}],\"internalType\":\"struct ExecutionTypes.ExecutionRequest\",\"name\":\"executionRequest\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint112\",\"name\":\"amount\",\"type\":\"uint112\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct TokenTypes.TokenAmount\",\"name\":\"tokenIn\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint112\",\"name\":\"amount\",\"type\":\"uint112\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct TokenTypes.TokenAmount\",\"name\":\"tokenOut\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint112\",\"name\":\"amount\",\"type\":\"uint112\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct TokenTypes.TokenAmount\",\"name\":\"routeAmount\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"routerData\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapTypes.RouterRequest[]\",\"name\":\"routes\",\"type\":\"tuple[]\"}],\"internalType\":\"struct SwapTypes.SwapRequest\",\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/dexible/interfaces/IDexible.sol\":\"IDexible\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[\":@openzeppelin/=src/@openzeppelin/\",\":contracts/common/=src/common/\",\":contracts/dexible/=src/dexible/\",\":contracts/token/=src/token/\",\":contracts/vault/=src/vault/\",\":forge-std/=lib/forge-std/src/\",\":hardhat/=src/hardhat/\"]},\"sources\":{\"src/@openzeppelin/contracts/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\",\"keccak256\":\"0x4ffc0547c02ad22925310c585c0f166f8759e2648a09e9b489100c42f15dd98d\",\"license\":\"MIT\"},\"src/@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"src/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"src/@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xf41ca991f30855bf80ffd11e9347856a517b977f0a6c2d52e6421a99b7840329\",\"license\":\"MIT\"},\"src/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9b72f93be69ca894d8492c244259615c4a742afc8d63720dbc8bb81087d9b238\",\"license\":\"MIT\"},\"src/@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf96f969e24029d43d0df89e59d365f277021dac62b48e1c1e3ebe0acdd7f1ca1\",\"license\":\"MIT\"},\"src/@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"src/common/ExecutionTypes.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.17;\\n\\nimport \\\"./TokenTypes.sol\\\";\\n\\n/**\\n * These types only relevant for relay-based submissions through protocol\\n */\\nlibrary ExecutionTypes {\\n\\n    /**\\n     * Basic fee information which includes any payments to be made to affiliates.\\n     */\\n    struct FeeDetails {\\n\\n        //the fee token to pay\\n        IERC20 feeToken;\\n\\n        //affiliate address to pay affiliate fee\\n        address affiliate;\\n\\n        //fee to pay affiliate\\n        uint affiliatePortion;\\n    }\\n\\n    /**\\n     * Shared information in every execution request. This will evolve \\n     * over time to support signatures and privacy proofs as the protocol\\n     * decentralizes\\n     */\\n    struct ExecutionRequest {\\n        //account requesting this execution\\n        address requester;\\n\\n        //fees info\\n        FeeDetails fee;\\n    }\\n}\",\"keccak256\":\"0x4906aad1bdf7e7dcf0f242201693f26990779c50d21da95e98412121fc9d8ff7\",\"license\":\"Unlicense\"},\"src/common/IPausable.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.17;\\n\\ninterface IPausable {\\n\\n    event Paused();\\n    event Resumed();\\n\\n    function pause() external;\\n    function resume() external;\\n}\",\"keccak256\":\"0x389b2da724bea04ecddbb89ab8cf2ac833724649ae1c95be88a5e15fc0737968\",\"license\":\"Unlicense\"},\"src/common/SwapTypes.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.17;\\n\\nimport \\\"./TokenTypes.sol\\\";\\nimport \\\"./ExecutionTypes.sol\\\";\\n\\n/**\\n * Swap data strutures to submit for execution\\n */\\nlibrary SwapTypes {\\n\\n    /**\\n     * Individual router called to execute some action. Only approved \\n     * router addresses will execute successfully\\n     */\\n    struct RouterRequest {\\n        //router contract that handles the specific route data\\n        address router;\\n\\n        //any spend allowance approval required\\n        address spender;\\n\\n        //the amount to send to the router\\n        TokenTypes.TokenAmount routeAmount;\\n\\n        //the data to use for calling the router\\n        bytes routerData;\\n    }\\n\\n    /**\\n     * Swap request that is restricted to only relay-based executions. This prevents\\n     * applying discounts through sybil attacks and affiliate addresses.\\n     */\\n    struct SwapRequest {\\n\\n        //general execution request details\\n        ExecutionTypes.ExecutionRequest executionRequest;\\n\\n        //input token and amount\\n        TokenTypes.TokenAmount tokenIn;\\n\\n        //expected min output and amount\\n        TokenTypes.TokenAmount tokenOut;\\n\\n        //array of routes to call to perform swaps\\n        RouterRequest[] routes;\\n    }\\n\\n    /**\\n     * This is used when the caller is also the trader.\\n     */\\n    struct SelfSwap {\\n        //fee token paying in\\n        IERC20 feeToken;\\n\\n        //input token and full amount\\n        /*\\n         * NOTE: it's possible to swap native asset vs. wrapped asset when self-submitting. Could\\n         * use some standard \\\"ETH\\\" address to represent native asset and then verify value sent\\n         * with txn. Then wrap that in the token for swapping as part of the trade.\\n         */\\n        TokenTypes.TokenAmount tokenIn;\\n\\n        //output token and minimum amount out expected\\n        TokenTypes.TokenAmount tokenOut;\\n\\n        //the routers to call\\n        RouterRequest[] routes;\\n    }\\n}\",\"keccak256\":\"0xc8aa48ea0c66bd176a535b9479d34a55b3c530d322496447a207a54dea682c3d\",\"license\":\"Unlicense\"},\"src/common/TokenTypes.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.17;\\n\\n\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nlibrary TokenTypes {\\n\\n    /**\\n     * Wrapper structure for token and an amount\\n     */\\n    struct TokenAmount {\\n        uint112 amount;\\n        IERC20 token;\\n    }\\n    \\n}\",\"keccak256\":\"0x7c1b8d6d3be1e957bb0515dafd8247a724a3b7efc29047220b13b5091585dbd5\",\"license\":\"Unlicense\"},\"src/dexible/interfaces/IDexible.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.17;\\n\\nimport \\\"./IDexibleView.sol\\\";\\nimport \\\"./ISwapHandler.sol\\\";\\nimport \\\"./IDexibleEvents.sol\\\";\\nimport \\\"./IDexibleConfig.sol\\\";\\n\\ninterface IDexible is IDexibleView, IDexibleConfig, ISwapHandler {\\n\\n    \\n}\",\"keccak256\":\"0x463dc2050dbcf1fdc67d2a23c9b6fc6d02c562e4748a80a5489f0a0c88d8ef41\",\"license\":\"Unlicense\"},\"src/dexible/interfaces/IDexibleConfig.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.17;\\n\\nimport \\\"../../vault/interfaces/ICommunityVault.sol\\\";\\nimport \\\"../oracles/IArbitrumGasOracle.sol\\\";\\nimport \\\"../../common/IPausable.sol\\\";\\n\\ninterface IDexibleConfig is IPausable {\\n\\n    event SplitRatioChanged(uint8 newRate);\\n    event StdBpsChanged(uint16 newRate);\\n    event MinBpsChanged(uint16 newRate);\\n    event MinFeeChanged(uint112 newMin);\\n    event VaultChanged(address newVault);\\n    event TreasuryChanged(address newTreasury);\\n    event ArbGasOracleChanged(address newVault);\\n\\n    function setRevshareSplitRatio(uint8 bps) external;\\n         \\n    function setStdBpsRate(uint16 bps) external;\\n\\n    function setMinBpsRate(uint16 bps) external;\\n\\n    function setMinFeeUSD(uint112 minFee) external;\\n        \\n    function setCommunityVault(ICommunityVault vault) external;\\n\\n    function setTreasury(address t) external;\\n    \\n    function setArbitrumGasOracle(IArbitrumGasOracle oracle) external;\\n}\",\"keccak256\":\"0x78b8f2ff100f808f61a2a4965b8f89b4f156f5dbea372e15bea397088ee6b64b\",\"license\":\"Unlicense\"},\"src/dexible/interfaces/IDexibleEvents.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.17;\\n\\ninterface IDexibleEvents {\\n\\n    event SwapFailed(address indexed trader, \\n                     address feeToken, \\n                     uint gasFeePaid);\\n    event SwapSuccess(address indexed trader,\\n                        address indexed affiliate,\\n                        uint inputAmount,\\n                        uint outputAmount,\\n                        address feeToken,\\n                        uint gasFee,\\n                        uint affiliateFee,\\n                        uint dexibleFee);\\n    event AffiliatePaid(address indexed affiliate, address token, uint amount);\\n\\n    event PaidGasFunds(address indexed relay, uint amount);\\n    event InsufficientGasFunds(address indexed relay, uint amount);\\n    event ChangedRevshareVault(address indexed old, address indexed newRevshare);\\n    event ChangedRevshareSplit(uint8 split);\\n    event ChangedBpsRates(uint32 stdRate, uint32 minRate);\\n    \\n}\",\"keccak256\":\"0xda9c72c976099e0596c803d099da427978875f124b3c6e78a8e92a50a84c3d4c\",\"license\":\"Unlicense\"},\"src/dexible/interfaces/IDexibleView.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.17;\\n\\ninterface IDexibleView {\\n    function revshareSplitRatio() external view returns (uint8);\\n         \\n    function stdBpsRate() external view returns (uint16);\\n\\n    function minBpsRate() external view returns (uint16);\\n\\n    function minFeeUSD() external view returns (uint112);\\n        \\n    function communityVault() external view returns(address);\\n\\n    function treasury() external view returns (address);\\n\\n    function dxblToken() external view returns(address);\\n\\n    function arbitrumGasOracle() external view returns(address);\\n}\",\"keccak256\":\"0x53a6a5d7652501593fd1f3ece41fad990bc1eed785884476730df3f4fa31b1bf\",\"license\":\"Unlicense\"},\"src/dexible/interfaces/ISwapHandler.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.17;\\n\\nimport \\\"../../common/SwapTypes.sol\\\";\\nimport \\\"./IDexibleEvents.sol\\\";\\n\\ninterface ISwapHandler is IDexibleEvents {\\n\\n    function swap(SwapTypes.SwapRequest calldata request) external;\\n    function selfSwap(SwapTypes.SelfSwap calldata request) external;\\n}\",\"keccak256\":\"0x2086cbc9aac7ee424571e0c6f086256f2dddff56e248e29acac51f2349a18e86\",\"license\":\"Unlicense\"},\"src/dexible/oracles/IArbitrumGasOracle.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.17;\\n\\ninterface IArbitrumGasOracle {\\n    function calculateGasCost(uint callDataSize, uint l2GasUsed) external view returns (uint);\\n}\",\"keccak256\":\"0x1d3c8517ccbbeca13982398e259fcdf645c34b3e003808bbd21c311594d59097\",\"license\":\"Unlicense\"},\"src/token/IDXBL.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\ninterface IDXBL is IERC20, IERC20Metadata {\\n    struct FeeRequest {\\n        bool referred;\\n        address trader;\\n        uint amt;\\n        uint dxblBalance;\\n        uint16 stdBpsRate;\\n        uint16 minBpsRate;\\n    }\\n\\n    function minter() external view returns (address);\\n    function discountPerTokenBps() external view returns(uint32);\\n\\n    function mint(address acct, uint amt) external;\\n    function burn(address holder, uint amt) external;\\n    function setDiscountRate(uint32 discount) external;\\n    function setNewMinter(address minter) external;\\n    function computeDiscountedFee(FeeRequest calldata request) external view returns(uint);\\n}\",\"keccak256\":\"0x5c7e94839ff1ff8d19ed800cbb7a9af9ea24d178ec1cca6c84c0b914636494ef\",\"license\":\"Unlicense\"},\"src/vault/VaultStorage.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.17;\\n\\nimport \\\"../token/IDXBL.sol\\\";\\nimport \\\"./interfaces/IPriceFeed.sol\\\";\\n\\nlibrary VaultStorage {\\n\\n    bytes32 constant VAULT_STORAGE_KEY = 0xbfa76ec2967ed7f8d3d40cd552f1451ab03573b596bfce931a6a016f7733078c;\\n\\n    \\n    //mint rate bucket\\n    struct MintRateRangeConfig {\\n        uint16 minMMVolume;\\n        uint16 maxMMVolume;\\n        uint rate;\\n    }\\n\\n    //fee token and its associated chainlink feed\\n    struct FeeTokenConfig {\\n        address[] feeTokens;\\n        address[] priceFeeds;\\n    }\\n\\n    //initialize config to intialize storage\\n    struct VaultConfig {\\n\\n        //the address of the wrapped native token\\n        address wrappedNativeToken;\\n\\n        //address of the multisig that will administer this vault\\n        address adminMultiSig;\\n\\n\\n        //seconds for any timelock-based changes\\n        uint32 timelockSeconds;\\n\\n        //starting volume needed to mint a single DXBL token. This increases\\n        //as we get closer to reaching the daily goal\\n        uint baseMintThreshold;\\n\\n        //initial rate ranges to apply\\n        MintRateRangeConfig[] rateRanges;\\n\\n        //set of fee token/price feed pairs to initialize with\\n        FeeTokenConfig feeTokenConfig;\\n    }\\n\\n    //stored mint rate range\\n    struct MintRateRange {\\n        uint16 minMMVolume;\\n        uint16 maxMMVolume;\\n        uint rate;\\n        uint index;\\n    }\\n\\n    //price feed for a fee token\\n    struct PriceFeed {\\n        IPriceFeed feed;\\n        uint8 decimals;\\n    }\\n\\n    /*****************************************************************************************\\n     * STORAGE\\n    ******************************************************************************************/\\n    \\n    \\n    struct VaultData {\\n        //whether the vault is paused\\n        bool paused;\\n\\n        //admin multi sig\\n        address adminMultiSig;\\n\\n        //token address\\n        IDXBL dxbl;\\n\\n        //dexible settlement contract that is allowed to call the vault\\n        address dexible;\\n\\n        //wrapped native asset address for gas computation\\n        address wrappedNativeToken;\\n\\n        //pending migration to new vault\\n        address pendingMigrationTarget;\\n\\n        //time before migration allowed\\n        uint32 timelockSeconds;\\n\\n        //base volume needed to mint a single DXBL token. This increases\\n        //as we get closer to reaching the daily goal\\n        uint baseMintThreshold;\\n\\n        //current daily volume adjusted each hour\\n        uint currentVolume;\\n\\n        //to compute what hourly slots to deduct from 24hr window\\n        uint lastTradeTimestamp;\\n\\n        //can migrate the contract to a new vault after this time\\n        uint migrateAfterTime;\\n\\n        //all known fee tokens. Some may be inactive\\n        IERC20[] feeTokens;\\n\\n        //the current volume range we're operating in for mint rate\\n        MintRateRange currentMintRate;\\n\\n        //The ranges of 24hr volume and their percentage-per-MM increase to \\n        //mint a single token\\n        MintRateRange[] mintRateRanges;\\n\\n        //hourly volume totals to adjust current volume every 24 hr slot\\n        uint[24] hourlyVolume;\\n\\n        //fee token decimals\\n        mapping(address => uint8) tokenDecimals;\\n\\n        //all allowed fee tokens mapped to their price feed address\\n        mapping(address => PriceFeed) allowedFeeTokens;\\n    }\\n\\n    /**\\n     * If a migration occurs from the V1 vault to a new vault, this structure is forwarded\\n     * after all fee token balances are transferred. It is expected that the new vault will have\\n     * its fee token, minting rates, and starting mint rates mapped out as part of its deployment.\\n     * The migration is intended to get the new vault into a state where it knows the last 24hrs\\n     * of volume and can pick up where this vault leaves off but with new settings and capabilities.\\n     */\\n    struct VaultMigrationV1 {\\n        //current daily volume adjusted each hour\\n        uint currentVolume;\\n\\n        //to compute what hourly slots to deduct from 24hr window\\n        uint lastTradeTimestamp;\\n\\n        //hourly volume totals to adjust in new contract\\n        uint[24] hourlyVolume;\\n\\n        //the current volume range we're operating in for mint rate\\n        MintRateRange currentMintRate;\\n    }\\n\\n    function load() internal pure returns (VaultData storage ds) {\\n        assembly { ds.slot := VAULT_STORAGE_KEY }\\n    }\\n}\",\"keccak256\":\"0x06f4025a6c0778c764e67e3605488a0e1ae0fba4a98bb9dbdd2952afa61efde5\",\"license\":\"Unlicense\"},\"src/vault/interfaces/ICommunityVault.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.17;\\n\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"./ICommunityVaultEvents.sol\\\";\\nimport \\\"./V1Migrateable.sol\\\";\\nimport \\\"./IStorageView.sol\\\";\\nimport \\\"./IComputationalView.sol\\\";\\nimport \\\"./IRewardHandler.sol\\\";\\nimport \\\"../../common/IPausable.sol\\\";\\n\\ninterface ICommunityVault is IStorageView, IComputationalView, IRewardHandler, ICommunityVaultEvents, IPausable, V1Migrateable {\\n    function redeemDXBL(address feeToken, uint dxblAmount, uint minOutAmount, bool unwrapNative) external;\\n}\",\"keccak256\":\"0x6c951b24fba22f8557c3001a9cfdcb6f58096b70047a699eac0705a85a9fdfa7\",\"license\":\"Unlicense\"},\"src/vault/interfaces/ICommunityVaultEvents.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.17;\\n\\ninterface ICommunityVaultEvents {\\n\\n    event DXBLRedeemed(address holder, uint dxblAmount, address rewardToken, uint rewardAmount);\\n}\",\"keccak256\":\"0xc947f6e92177e75cbbc9643473b1e72c6ae4a1ecc3ecfae75c82747b3af9513e\",\"license\":\"Unlicense\"},\"src/vault/interfaces/IComputationalView.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.17;\\n\\ninterface IComputationalView {\\n\\n    struct AssetInfo {\\n        address token;\\n        uint balance;\\n        uint usdValue;\\n        uint usdPrice;\\n    }\\n\\n    function convertGasToFeeToken(address feeToken, uint gasCost) external view returns (uint);\\n    function estimateRedemption(address feeToken, uint dxblAmount) external view returns(uint);\\n    function feeTokenPriceUSD(address feeToken) external view returns (uint);\\n    function aumUSD() external view returns(uint);\\n    function currentNavUSD() external view returns(uint);\\n    function assets() external view returns (AssetInfo[] memory);\\n    function currentMintRateUSD() external view returns (uint);\\n    function computeVolumeUSD(address feeToken, uint amount) external view returns(uint);\\n\\n}\",\"keccak256\":\"0xc0e46b88fd0f1381ada98e1e202068fefb7dca14d74e273e1d5bd264966c9a1d\",\"license\":\"Unlicense\"},\"src/vault/interfaces/IPriceFeed.sol\":{\"content\":\"\\n//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.17;\\n\\n/**\\n * Interface for Chainlink oracle feeds\\n */\\ninterface IPriceFeed {\\n    function latestRoundData() external view\\n    returns (\\n        uint80 roundId,\\n        int256 answer,\\n        uint256 startedAt,\\n        uint256 updatedAt,\\n        uint80 answeredInRound\\n    );\\n    function decimals() external view returns (uint8);\\n}\",\"keccak256\":\"0x151d6516db0e8639f2c0aae6a0d3dd7fc9befc2d179ac8b08ea8830253cbb544\",\"license\":\"Unlicense\"},\"src/vault/interfaces/IRewardHandler.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.17;\\n\\ninterface IRewardHandler {\\n\\n    /**\\n     * Modification functions\\n     */\\n    function rewardTrader(address trader, address feeToken, uint amount) external;\\n}\",\"keccak256\":\"0x103b1b3c548036a1ba6fefb5bf923eda05a1a66732e05c8f2553b00625c6aabd\",\"license\":\"Unlicense\"},\"src/vault/interfaces/IStorageView.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.17;\\n\\ninterface IStorageView {\\n\\n    /**\\n     * Storage variable view functions\\n     */\\n    function isFeeTokenAllowed(address tokens) external view returns (bool);\\n    function discountBps() external view returns(uint32);\\n    function dailyVolumeUSD() external view returns(uint);\\n    function paused() external view returns (bool);\\n    function adminMultiSig() external view returns (address);\\n    function dxblToken() external view returns (address);\\n    function dexibleContract() external view returns (address);\\n    function wrappedNativeToken() external view returns (address);\\n    function timelockSeconds() external view returns (uint32);\\n    function baseMintThreshold() external view returns (uint);\\n}\",\"keccak256\":\"0xe582187e92b985d1f5c557d74c715f38cc3475215138444faf0fa58c30fabdb0\",\"license\":\"Unlicense\"},\"src/vault/interfaces/V1Migrateable.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.17;\\n\\nimport \\\"../VaultStorage.sol\\\";\\n\\ninterface V1MigrationTarget {\\n    /**\\n     * Call from current vault to migrate the state of the old vault to the new one. \\n     */\\n    function migrationFromV1(VaultStorage.VaultMigrationV1 memory data) external;\\n}\\n\\ninterface V1Migrateable {\\n\\n    event MigrationScheduled(address indexed newVault, uint afterTime);\\n    event MigrationCancelled(address indexed newVault);\\n    event VaultMigrated(address indexed newVault);\\n\\n    function scheduleMigration(V1MigrationTarget target) external;\\n\\n    function cancelMigration() external;\\n\\n    function canMigrate() external view returns (bool);\\n\\n    /**\\n     * Migrate the vault to a new vault address that implements the target interface\\n     * to receive this vault's state. This will transfer all fee token assets to the \\n     * new vault. This can only be called after timelock is expired.\\n     */\\n    function migrateV1() external;\\n    \\n}\",\"keccak256\":\"0x7950798d6d2e6b2960de25d1a4b8383e13dccb9bddb077859528cff48f39cf1e\",\"license\":\"Unlicense\"}},\"version\":1}","metadata":{"compiler":{"version":"0.8.17+commit.8df45f5f"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"address","name":"affiliate","type":"address","indexed":true},{"internalType":"address","name":"token","type":"address","indexed":false},{"internalType":"uint256","name":"amount","type":"uint256","indexed":false}],"type":"event","name":"AffiliatePaid","anonymous":false},{"inputs":[{"internalType":"address","name":"newVault","type":"address","indexed":false}],"type":"event","name":"ArbGasOracleChanged","anonymous":false},{"inputs":[{"internalType":"uint32","name":"stdRate","type":"uint32","indexed":false},{"internalType":"uint32","name":"minRate","type":"uint32","indexed":false}],"type":"event","name":"ChangedBpsRates","anonymous":false},{"inputs":[{"internalType":"uint8","name":"split","type":"uint8","indexed":false}],"type":"event","name":"ChangedRevshareSplit","anonymous":false},{"inputs":[{"internalType":"address","name":"old","type":"address","indexed":true},{"internalType":"address","name":"newRevshare","type":"address","indexed":true}],"type":"event","name":"ChangedRevshareVault","anonymous":false},{"inputs":[{"internalType":"address","name":"relay","type":"address","indexed":true},{"internalType":"uint256","name":"amount","type":"uint256","indexed":false}],"type":"event","name":"InsufficientGasFunds","anonymous":false},{"inputs":[{"internalType":"uint16","name":"newRate","type":"uint16","indexed":false}],"type":"event","name":"MinBpsChanged","anonymous":false},{"inputs":[{"internalType":"uint112","name":"newMin","type":"uint112","indexed":false}],"type":"event","name":"MinFeeChanged","anonymous":false},{"inputs":[{"internalType":"address","name":"relay","type":"address","indexed":true},{"internalType":"uint256","name":"amount","type":"uint256","indexed":false}],"type":"event","name":"PaidGasFunds","anonymous":false},{"inputs":[],"type":"event","name":"Paused","anonymous":false},{"inputs":[],"type":"event","name":"Resumed","anonymous":false},{"inputs":[{"internalType":"uint8","name":"newRate","type":"uint8","indexed":false}],"type":"event","name":"SplitRatioChanged","anonymous":false},{"inputs":[{"internalType":"uint16","name":"newRate","type":"uint16","indexed":false}],"type":"event","name":"StdBpsChanged","anonymous":false},{"inputs":[{"internalType":"address","name":"trader","type":"address","indexed":true},{"internalType":"address","name":"feeToken","type":"address","indexed":false},{"internalType":"uint256","name":"gasFeePaid","type":"uint256","indexed":false}],"type":"event","name":"SwapFailed","anonymous":false},{"inputs":[{"internalType":"address","name":"trader","type":"address","indexed":true},{"internalType":"address","name":"affiliate","type":"address","indexed":true},{"internalType":"uint256","name":"inputAmount","type":"uint256","indexed":false},{"internalType":"uint256","name":"outputAmount","type":"uint256","indexed":false},{"internalType":"address","name":"feeToken","type":"address","indexed":false},{"internalType":"uint256","name":"gasFee","type":"uint256","indexed":false},{"internalType":"uint256","name":"affiliateFee","type":"uint256","indexed":false},{"internalType":"uint256","name":"dexibleFee","type":"uint256","indexed":false}],"type":"event","name":"SwapSuccess","anonymous":false},{"inputs":[{"internalType":"address","name":"newTreasury","type":"address","indexed":false}],"type":"event","name":"TreasuryChanged","anonymous":false},{"inputs":[{"internalType":"address","name":"newVault","type":"address","indexed":false}],"type":"event","name":"VaultChanged","anonymous":false},{"inputs":[],"stateMutability":"view","type":"function","name":"arbitrumGasOracle","outputs":[{"internalType":"address","name":"","type":"address"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"communityVault","outputs":[{"internalType":"address","name":"","type":"address"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"dxblToken","outputs":[{"internalType":"address","name":"","type":"address"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"minBpsRate","outputs":[{"internalType":"uint16","name":"","type":"uint16"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"minFeeUSD","outputs":[{"internalType":"uint112","name":"","type":"uint112"}]},{"inputs":[],"stateMutability":"nonpayable","type":"function","name":"pause"},{"inputs":[],"stateMutability":"nonpayable","type":"function","name":"resume"},{"inputs":[],"stateMutability":"view","type":"function","name":"revshareSplitRatio","outputs":[{"internalType":"uint8","name":"","type":"uint8"}]},{"inputs":[{"internalType":"struct SwapTypes.SelfSwap","name":"request","type":"tuple","components":[{"internalType":"contract IERC20","name":"feeToken","type":"address"},{"internalType":"struct TokenTypes.TokenAmount","name":"tokenIn","type":"tuple","components":[{"internalType":"uint112","name":"amount","type":"uint112"},{"internalType":"contract IERC20","name":"token","type":"address"}]},{"internalType":"struct TokenTypes.TokenAmount","name":"tokenOut","type":"tuple","components":[{"internalType":"uint112","name":"amount","type":"uint112"},{"internalType":"contract IERC20","name":"token","type":"address"}]},{"internalType":"struct SwapTypes.RouterRequest[]","name":"routes","type":"tuple[]","components":[{"internalType":"address","name":"router","type":"address"},{"internalType":"address","name":"spender","type":"address"},{"internalType":"struct TokenTypes.TokenAmount","name":"routeAmount","type":"tuple","components":[{"internalType":"uint112","name":"amount","type":"uint112"},{"internalType":"contract IERC20","name":"token","type":"address"}]},{"internalType":"bytes","name":"routerData","type":"bytes"}]}]}],"stateMutability":"nonpayable","type":"function","name":"selfSwap"},{"inputs":[{"internalType":"contract IArbitrumGasOracle","name":"oracle","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"setArbitrumGasOracle"},{"inputs":[{"internalType":"contract ICommunityVault","name":"vault","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"setCommunityVault"},{"inputs":[{"internalType":"uint16","name":"bps","type":"uint16"}],"stateMutability":"nonpayable","type":"function","name":"setMinBpsRate"},{"inputs":[{"internalType":"uint112","name":"minFee","type":"uint112"}],"stateMutability":"nonpayable","type":"function","name":"setMinFeeUSD"},{"inputs":[{"internalType":"uint8","name":"bps","type":"uint8"}],"stateMutability":"nonpayable","type":"function","name":"setRevshareSplitRatio"},{"inputs":[{"internalType":"uint16","name":"bps","type":"uint16"}],"stateMutability":"nonpayable","type":"function","name":"setStdBpsRate"},{"inputs":[{"internalType":"address","name":"t","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"setTreasury"},{"inputs":[],"stateMutability":"view","type":"function","name":"stdBpsRate","outputs":[{"internalType":"uint16","name":"","type":"uint16"}]},{"inputs":[{"internalType":"struct SwapTypes.SwapRequest","name":"request","type":"tuple","components":[{"internalType":"struct ExecutionTypes.ExecutionRequest","name":"executionRequest","type":"tuple","components":[{"internalType":"address","name":"requester","type":"address"},{"internalType":"struct ExecutionTypes.FeeDetails","name":"fee","type":"tuple","components":[{"internalType":"contract IERC20","name":"feeToken","type":"address"},{"internalType":"address","name":"affiliate","type":"address"},{"internalType":"uint256","name":"affiliatePortion","type":"uint256"}]}]},{"internalType":"struct TokenTypes.TokenAmount","name":"tokenIn","type":"tuple","components":[{"internalType":"uint112","name":"amount","type":"uint112"},{"internalType":"contract IERC20","name":"token","type":"address"}]},{"internalType":"struct TokenTypes.TokenAmount","name":"tokenOut","type":"tuple","components":[{"internalType":"uint112","name":"amount","type":"uint112"},{"internalType":"contract IERC20","name":"token","type":"address"}]},{"internalType":"struct SwapTypes.RouterRequest[]","name":"routes","type":"tuple[]","components":[{"internalType":"address","name":"router","type":"address"},{"internalType":"address","name":"spender","type":"address"},{"internalType":"struct TokenTypes.TokenAmount","name":"routeAmount","type":"tuple","components":[{"internalType":"uint112","name":"amount","type":"uint112"},{"internalType":"contract IERC20","name":"token","type":"address"}]},{"internalType":"bytes","name":"routerData","type":"bytes"}]}]}],"stateMutability":"nonpayable","type":"function","name":"swap"},{"inputs":[],"stateMutability":"view","type":"function","name":"treasury","outputs":[{"internalType":"address","name":"","type":"address"}]}],"devdoc":{"kind":"dev","methods":{},"version":1},"userdoc":{"kind":"user","methods":{},"version":1}},"settings":{"remappings":["@openzeppelin/=src/@openzeppelin/","contracts/common/=src/common/","contracts/dexible/=src/dexible/","contracts/token/=src/token/","contracts/vault/=src/vault/","forge-std/=lib/forge-std/src/","hardhat/=src/hardhat/"],"optimizer":{"enabled":true,"runs":100},"metadata":{"useLiteralContent":true,"bytecodeHash":"ipfs"},"compilationTarget":{"src/dexible/interfaces/IDexible.sol":"IDexible"},"evmVersion":"london","libraries":{}},"sources":{"src/@openzeppelin/contracts/token/ERC20/ERC20.sol":{"keccak256":"0x4ffc0547c02ad22925310c585c0f166f8759e2648a09e9b489100c42f15dd98d","urls":[],"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n","license":"MIT"},"src/@openzeppelin/contracts/token/ERC20/IERC20.sol":{"keccak256":"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b","urls":[],"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n","license":"MIT"},"src/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol":{"keccak256":"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca","urls":[],"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n","license":"MIT"},"src/@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol":{"keccak256":"0xf41ca991f30855bf80ffd11e9347856a517b977f0a6c2d52e6421a99b7840329","urls":[],"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n","license":"MIT"},"src/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol":{"keccak256":"0x9b72f93be69ca894d8492c244259615c4a742afc8d63720dbc8bb81087d9b238","urls":[],"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n","license":"MIT"},"src/@openzeppelin/contracts/utils/Address.sol":{"keccak256":"0xf96f969e24029d43d0df89e59d365f277021dac62b48e1c1e3ebe0acdd7f1ca1","urls":[],"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n","license":"MIT"},"src/@openzeppelin/contracts/utils/Context.sol":{"keccak256":"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7","urls":[],"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n","license":"MIT"},"src/common/ExecutionTypes.sol":{"keccak256":"0x4906aad1bdf7e7dcf0f242201693f26990779c50d21da95e98412121fc9d8ff7","urls":[],"content":"//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.17;\n\nimport \"./TokenTypes.sol\";\n\n/**\n * These types only relevant for relay-based submissions through protocol\n */\nlibrary ExecutionTypes {\n\n    /**\n     * Basic fee information which includes any payments to be made to affiliates.\n     */\n    struct FeeDetails {\n\n        //the fee token to pay\n        IERC20 feeToken;\n\n        //affiliate address to pay affiliate fee\n        address affiliate;\n\n        //fee to pay affiliate\n        uint affiliatePortion;\n    }\n\n    /**\n     * Shared information in every execution request. This will evolve \n     * over time to support signatures and privacy proofs as the protocol\n     * decentralizes\n     */\n    struct ExecutionRequest {\n        //account requesting this execution\n        address requester;\n\n        //fees info\n        FeeDetails fee;\n    }\n}","license":"Unlicense"},"src/common/IPausable.sol":{"keccak256":"0x389b2da724bea04ecddbb89ab8cf2ac833724649ae1c95be88a5e15fc0737968","urls":[],"content":"//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.17;\n\ninterface IPausable {\n\n    event Paused();\n    event Resumed();\n\n    function pause() external;\n    function resume() external;\n}","license":"Unlicense"},"src/common/SwapTypes.sol":{"keccak256":"0xc8aa48ea0c66bd176a535b9479d34a55b3c530d322496447a207a54dea682c3d","urls":[],"content":"//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.17;\n\nimport \"./TokenTypes.sol\";\nimport \"./ExecutionTypes.sol\";\n\n/**\n * Swap data strutures to submit for execution\n */\nlibrary SwapTypes {\n\n    /**\n     * Individual router called to execute some action. Only approved \n     * router addresses will execute successfully\n     */\n    struct RouterRequest {\n        //router contract that handles the specific route data\n        address router;\n\n        //any spend allowance approval required\n        address spender;\n\n        //the amount to send to the router\n        TokenTypes.TokenAmount routeAmount;\n\n        //the data to use for calling the router\n        bytes routerData;\n    }\n\n    /**\n     * Swap request that is restricted to only relay-based executions. This prevents\n     * applying discounts through sybil attacks and affiliate addresses.\n     */\n    struct SwapRequest {\n\n        //general execution request details\n        ExecutionTypes.ExecutionRequest executionRequest;\n\n        //input token and amount\n        TokenTypes.TokenAmount tokenIn;\n\n        //expected min output and amount\n        TokenTypes.TokenAmount tokenOut;\n\n        //array of routes to call to perform swaps\n        RouterRequest[] routes;\n    }\n\n    /**\n     * This is used when the caller is also the trader.\n     */\n    struct SelfSwap {\n        //fee token paying in\n        IERC20 feeToken;\n\n        //input token and full amount\n        /*\n         * NOTE: it's possible to swap native asset vs. wrapped asset when self-submitting. Could\n         * use some standard \"ETH\" address to represent native asset and then verify value sent\n         * with txn. Then wrap that in the token for swapping as part of the trade.\n         */\n        TokenTypes.TokenAmount tokenIn;\n\n        //output token and minimum amount out expected\n        TokenTypes.TokenAmount tokenOut;\n\n        //the routers to call\n        RouterRequest[] routes;\n    }\n}","license":"Unlicense"},"src/common/TokenTypes.sol":{"keccak256":"0x7c1b8d6d3be1e957bb0515dafd8247a724a3b7efc29047220b13b5091585dbd5","urls":[],"content":"//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.17;\n\n\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nlibrary TokenTypes {\n\n    /**\n     * Wrapper structure for token and an amount\n     */\n    struct TokenAmount {\n        uint112 amount;\n        IERC20 token;\n    }\n    \n}","license":"Unlicense"},"src/dexible/interfaces/IDexible.sol":{"keccak256":"0x463dc2050dbcf1fdc67d2a23c9b6fc6d02c562e4748a80a5489f0a0c88d8ef41","urls":[],"content":"//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.17;\n\nimport \"./IDexibleView.sol\";\nimport \"./ISwapHandler.sol\";\nimport \"./IDexibleEvents.sol\";\nimport \"./IDexibleConfig.sol\";\n\ninterface IDexible is IDexibleView, IDexibleConfig, ISwapHandler {\n\n    \n}","license":"Unlicense"},"src/dexible/interfaces/IDexibleConfig.sol":{"keccak256":"0x78b8f2ff100f808f61a2a4965b8f89b4f156f5dbea372e15bea397088ee6b64b","urls":[],"content":"//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.17;\n\nimport \"../../vault/interfaces/ICommunityVault.sol\";\nimport \"../oracles/IArbitrumGasOracle.sol\";\nimport \"../../common/IPausable.sol\";\n\ninterface IDexibleConfig is IPausable {\n\n    event SplitRatioChanged(uint8 newRate);\n    event StdBpsChanged(uint16 newRate);\n    event MinBpsChanged(uint16 newRate);\n    event MinFeeChanged(uint112 newMin);\n    event VaultChanged(address newVault);\n    event TreasuryChanged(address newTreasury);\n    event ArbGasOracleChanged(address newVault);\n\n    function setRevshareSplitRatio(uint8 bps) external;\n         \n    function setStdBpsRate(uint16 bps) external;\n\n    function setMinBpsRate(uint16 bps) external;\n\n    function setMinFeeUSD(uint112 minFee) external;\n        \n    function setCommunityVault(ICommunityVault vault) external;\n\n    function setTreasury(address t) external;\n    \n    function setArbitrumGasOracle(IArbitrumGasOracle oracle) external;\n}","license":"Unlicense"},"src/dexible/interfaces/IDexibleEvents.sol":{"keccak256":"0xda9c72c976099e0596c803d099da427978875f124b3c6e78a8e92a50a84c3d4c","urls":[],"content":"//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.17;\n\ninterface IDexibleEvents {\n\n    event SwapFailed(address indexed trader, \n                     address feeToken, \n                     uint gasFeePaid);\n    event SwapSuccess(address indexed trader,\n                        address indexed affiliate,\n                        uint inputAmount,\n                        uint outputAmount,\n                        address feeToken,\n                        uint gasFee,\n                        uint affiliateFee,\n                        uint dexibleFee);\n    event AffiliatePaid(address indexed affiliate, address token, uint amount);\n\n    event PaidGasFunds(address indexed relay, uint amount);\n    event InsufficientGasFunds(address indexed relay, uint amount);\n    event ChangedRevshareVault(address indexed old, address indexed newRevshare);\n    event ChangedRevshareSplit(uint8 split);\n    event ChangedBpsRates(uint32 stdRate, uint32 minRate);\n    \n}","license":"Unlicense"},"src/dexible/interfaces/IDexibleView.sol":{"keccak256":"0x53a6a5d7652501593fd1f3ece41fad990bc1eed785884476730df3f4fa31b1bf","urls":[],"content":"//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.17;\n\ninterface IDexibleView {\n    function revshareSplitRatio() external view returns (uint8);\n         \n    function stdBpsRate() external view returns (uint16);\n\n    function minBpsRate() external view returns (uint16);\n\n    function minFeeUSD() external view returns (uint112);\n        \n    function communityVault() external view returns(address);\n\n    function treasury() external view returns (address);\n\n    function dxblToken() external view returns(address);\n\n    function arbitrumGasOracle() external view returns(address);\n}","license":"Unlicense"},"src/dexible/interfaces/ISwapHandler.sol":{"keccak256":"0x2086cbc9aac7ee424571e0c6f086256f2dddff56e248e29acac51f2349a18e86","urls":[],"content":"//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.17;\n\nimport \"../../common/SwapTypes.sol\";\nimport \"./IDexibleEvents.sol\";\n\ninterface ISwapHandler is IDexibleEvents {\n\n    function swap(SwapTypes.SwapRequest calldata request) external;\n    function selfSwap(SwapTypes.SelfSwap calldata request) external;\n}","license":"Unlicense"},"src/dexible/oracles/IArbitrumGasOracle.sol":{"keccak256":"0x1d3c8517ccbbeca13982398e259fcdf645c34b3e003808bbd21c311594d59097","urls":[],"content":"//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.17;\n\ninterface IArbitrumGasOracle {\n    function calculateGasCost(uint callDataSize, uint l2GasUsed) external view returns (uint);\n}","license":"Unlicense"},"src/token/IDXBL.sol":{"keccak256":"0x5c7e94839ff1ff8d19ed800cbb7a9af9ea24d178ec1cca6c84c0b914636494ef","urls":[],"content":"//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\ninterface IDXBL is IERC20, IERC20Metadata {\n    struct FeeRequest {\n        bool referred;\n        address trader;\n        uint amt;\n        uint dxblBalance;\n        uint16 stdBpsRate;\n        uint16 minBpsRate;\n    }\n\n    function minter() external view returns (address);\n    function discountPerTokenBps() external view returns(uint32);\n\n    function mint(address acct, uint amt) external;\n    function burn(address holder, uint amt) external;\n    function setDiscountRate(uint32 discount) external;\n    function setNewMinter(address minter) external;\n    function computeDiscountedFee(FeeRequest calldata request) external view returns(uint);\n}","license":"Unlicense"},"src/vault/VaultStorage.sol":{"keccak256":"0x06f4025a6c0778c764e67e3605488a0e1ae0fba4a98bb9dbdd2952afa61efde5","urls":[],"content":"//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.17;\n\nimport \"../token/IDXBL.sol\";\nimport \"./interfaces/IPriceFeed.sol\";\n\nlibrary VaultStorage {\n\n    bytes32 constant VAULT_STORAGE_KEY = 0xbfa76ec2967ed7f8d3d40cd552f1451ab03573b596bfce931a6a016f7733078c;\n\n    \n    //mint rate bucket\n    struct MintRateRangeConfig {\n        uint16 minMMVolume;\n        uint16 maxMMVolume;\n        uint rate;\n    }\n\n    //fee token and its associated chainlink feed\n    struct FeeTokenConfig {\n        address[] feeTokens;\n        address[] priceFeeds;\n    }\n\n    //initialize config to intialize storage\n    struct VaultConfig {\n\n        //the address of the wrapped native token\n        address wrappedNativeToken;\n\n        //address of the multisig that will administer this vault\n        address adminMultiSig;\n\n\n        //seconds for any timelock-based changes\n        uint32 timelockSeconds;\n\n        //starting volume needed to mint a single DXBL token. This increases\n        //as we get closer to reaching the daily goal\n        uint baseMintThreshold;\n\n        //initial rate ranges to apply\n        MintRateRangeConfig[] rateRanges;\n\n        //set of fee token/price feed pairs to initialize with\n        FeeTokenConfig feeTokenConfig;\n    }\n\n    //stored mint rate range\n    struct MintRateRange {\n        uint16 minMMVolume;\n        uint16 maxMMVolume;\n        uint rate;\n        uint index;\n    }\n\n    //price feed for a fee token\n    struct PriceFeed {\n        IPriceFeed feed;\n        uint8 decimals;\n    }\n\n    /*****************************************************************************************\n     * STORAGE\n    ******************************************************************************************/\n    \n    \n    struct VaultData {\n        //whether the vault is paused\n        bool paused;\n\n        //admin multi sig\n        address adminMultiSig;\n\n        //token address\n        IDXBL dxbl;\n\n        //dexible settlement contract that is allowed to call the vault\n        address dexible;\n\n        //wrapped native asset address for gas computation\n        address wrappedNativeToken;\n\n        //pending migration to new vault\n        address pendingMigrationTarget;\n\n        //time before migration allowed\n        uint32 timelockSeconds;\n\n        //base volume needed to mint a single DXBL token. This increases\n        //as we get closer to reaching the daily goal\n        uint baseMintThreshold;\n\n        //current daily volume adjusted each hour\n        uint currentVolume;\n\n        //to compute what hourly slots to deduct from 24hr window\n        uint lastTradeTimestamp;\n\n        //can migrate the contract to a new vault after this time\n        uint migrateAfterTime;\n\n        //all known fee tokens. Some may be inactive\n        IERC20[] feeTokens;\n\n        //the current volume range we're operating in for mint rate\n        MintRateRange currentMintRate;\n\n        //The ranges of 24hr volume and their percentage-per-MM increase to \n        //mint a single token\n        MintRateRange[] mintRateRanges;\n\n        //hourly volume totals to adjust current volume every 24 hr slot\n        uint[24] hourlyVolume;\n\n        //fee token decimals\n        mapping(address => uint8) tokenDecimals;\n\n        //all allowed fee tokens mapped to their price feed address\n        mapping(address => PriceFeed) allowedFeeTokens;\n    }\n\n    /**\n     * If a migration occurs from the V1 vault to a new vault, this structure is forwarded\n     * after all fee token balances are transferred. It is expected that the new vault will have\n     * its fee token, minting rates, and starting mint rates mapped out as part of its deployment.\n     * The migration is intended to get the new vault into a state where it knows the last 24hrs\n     * of volume and can pick up where this vault leaves off but with new settings and capabilities.\n     */\n    struct VaultMigrationV1 {\n        //current daily volume adjusted each hour\n        uint currentVolume;\n\n        //to compute what hourly slots to deduct from 24hr window\n        uint lastTradeTimestamp;\n\n        //hourly volume totals to adjust in new contract\n        uint[24] hourlyVolume;\n\n        //the current volume range we're operating in for mint rate\n        MintRateRange currentMintRate;\n    }\n\n    function load() internal pure returns (VaultData storage ds) {\n        assembly { ds.slot := VAULT_STORAGE_KEY }\n    }\n}","license":"Unlicense"},"src/vault/interfaces/ICommunityVault.sol":{"keccak256":"0x6c951b24fba22f8557c3001a9cfdcb6f58096b70047a699eac0705a85a9fdfa7","urls":[],"content":"//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.17;\n\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./ICommunityVaultEvents.sol\";\nimport \"./V1Migrateable.sol\";\nimport \"./IStorageView.sol\";\nimport \"./IComputationalView.sol\";\nimport \"./IRewardHandler.sol\";\nimport \"../../common/IPausable.sol\";\n\ninterface ICommunityVault is IStorageView, IComputationalView, IRewardHandler, ICommunityVaultEvents, IPausable, V1Migrateable {\n    function redeemDXBL(address feeToken, uint dxblAmount, uint minOutAmount, bool unwrapNative) external;\n}","license":"Unlicense"},"src/vault/interfaces/ICommunityVaultEvents.sol":{"keccak256":"0xc947f6e92177e75cbbc9643473b1e72c6ae4a1ecc3ecfae75c82747b3af9513e","urls":[],"content":"//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.17;\n\ninterface ICommunityVaultEvents {\n\n    event DXBLRedeemed(address holder, uint dxblAmount, address rewardToken, uint rewardAmount);\n}","license":"Unlicense"},"src/vault/interfaces/IComputationalView.sol":{"keccak256":"0xc0e46b88fd0f1381ada98e1e202068fefb7dca14d74e273e1d5bd264966c9a1d","urls":[],"content":"//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.17;\n\ninterface IComputationalView {\n\n    struct AssetInfo {\n        address token;\n        uint balance;\n        uint usdValue;\n        uint usdPrice;\n    }\n\n    function convertGasToFeeToken(address feeToken, uint gasCost) external view returns (uint);\n    function estimateRedemption(address feeToken, uint dxblAmount) external view returns(uint);\n    function feeTokenPriceUSD(address feeToken) external view returns (uint);\n    function aumUSD() external view returns(uint);\n    function currentNavUSD() external view returns(uint);\n    function assets() external view returns (AssetInfo[] memory);\n    function currentMintRateUSD() external view returns (uint);\n    function computeVolumeUSD(address feeToken, uint amount) external view returns(uint);\n\n}","license":"Unlicense"},"src/vault/interfaces/IPriceFeed.sol":{"keccak256":"0x151d6516db0e8639f2c0aae6a0d3dd7fc9befc2d179ac8b08ea8830253cbb544","urls":[],"content":"\n//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.17;\n\n/**\n * Interface for Chainlink oracle feeds\n */\ninterface IPriceFeed {\n    function latestRoundData() external view\n    returns (\n        uint80 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80 answeredInRound\n    );\n    function decimals() external view returns (uint8);\n}","license":"Unlicense"},"src/vault/interfaces/IRewardHandler.sol":{"keccak256":"0x103b1b3c548036a1ba6fefb5bf923eda05a1a66732e05c8f2553b00625c6aabd","urls":[],"content":"//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.17;\n\ninterface IRewardHandler {\n\n    /**\n     * Modification functions\n     */\n    function rewardTrader(address trader, address feeToken, uint amount) external;\n}","license":"Unlicense"},"src/vault/interfaces/IStorageView.sol":{"keccak256":"0xe582187e92b985d1f5c557d74c715f38cc3475215138444faf0fa58c30fabdb0","urls":[],"content":"//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.17;\n\ninterface IStorageView {\n\n    /**\n     * Storage variable view functions\n     */\n    function isFeeTokenAllowed(address tokens) external view returns (bool);\n    function discountBps() external view returns(uint32);\n    function dailyVolumeUSD() external view returns(uint);\n    function paused() external view returns (bool);\n    function adminMultiSig() external view returns (address);\n    function dxblToken() external view returns (address);\n    function dexibleContract() external view returns (address);\n    function wrappedNativeToken() external view returns (address);\n    function timelockSeconds() external view returns (uint32);\n    function baseMintThreshold() external view returns (uint);\n}","license":"Unlicense"},"src/vault/interfaces/V1Migrateable.sol":{"keccak256":"0x7950798d6d2e6b2960de25d1a4b8383e13dccb9bddb077859528cff48f39cf1e","urls":[],"content":"//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.17;\n\nimport \"../VaultStorage.sol\";\n\ninterface V1MigrationTarget {\n    /**\n     * Call from current vault to migrate the state of the old vault to the new one. \n     */\n    function migrationFromV1(VaultStorage.VaultMigrationV1 memory data) external;\n}\n\ninterface V1Migrateable {\n\n    event MigrationScheduled(address indexed newVault, uint afterTime);\n    event MigrationCancelled(address indexed newVault);\n    event VaultMigrated(address indexed newVault);\n\n    function scheduleMigration(V1MigrationTarget target) external;\n\n    function cancelMigration() external;\n\n    function canMigrate() external view returns (bool);\n\n    /**\n     * Migrate the vault to a new vault address that implements the target interface\n     * to receive this vault's state. This will transfer all fee token assets to the \n     * new vault. This can only be called after timelock is expired.\n     */\n    function migrateV1() external;\n    \n}","license":"Unlicense"}},"version":1},"storageLayout":{"storage":[],"types":{}},"id":21}