# syntax

x, f, c ∈ <id>

type := int
      | uint
      | bool
      | address
      | mapping (T => T)
      | struct x { <type decl>; ... }

type decl := <type> <id>

value := int ∪ uint
       | true
       | false
       | <id>'('<value>*')'

projection = .x | [e]

expr := <id>
      | <value>
      | <expr> op <expr>
      | <expr><proj>+
      | <expr>{(<id> : <expr>)*}(<expr>*)

assignable := <type decl>
            | <id>
	    | <expr><proj>+

stmt := <type decl>
      | <expr>
      | <stmt>; <stmt>
      | <assignable> = <expr>
      | return <expr>
      | revert
      | if (<expr) { <stmt> } else { <stmt> }

target := <id> | <id>(<id><proj>*).<id>

spec := <target>{(<id>:<id>)*}(<id>*) returns (<id>*)
        requires <expr> ensures <expr> where <spec>*

mod := public | private // omitting external and internal

fun decl := function <id>(<type decl>*) returns (<type>*)

fun def := <spec> <fun decl> { <stmt> }

contract := contract <id> { <type decl>*; <fun def>* }

interface := interface <id> { <fun decl>* }

//opt_decl := { (<id> : <id>)* }
//opt := '{' (<id> : <expr>)* '}'

# translation semantics

idea:
- for a public function 𝑓,
  1 generate another public function 𝑓_pub that has the same interface.
    if 𝑓 has spec, then generate checks for its precondition and postcondition
    * if 𝑓 has a spec for its address arguments,
      wrap it.
    * if 𝑓 has a spec for its returned address,
      unwrap it.
    * the main body of 𝑓_pub is to call the private version 𝑓_pri
  2 generate a private function 𝑓_pri that has wrapped interface types
    * if 𝑓 has a spec for its address arguments,
      attach spec onto the wrapped argument.
    * if 𝑓 has a spec for its returned address,
      attach spec onto the wrapped returned value.

- for a private function 𝑔,
  only need to do step 2 as for public functions.

- statement/expression

  when wrap/unwrap expression???

- expression wrap



- type wrap

  wrap : type -> type
  wrap(int) = int
  wrap(uint) = uint
  wrap(bool) = bool
  wrap(address) = struct { address _addr; uint256 _spec}
  wrap(T1 ⇒ T2) = (T1 ⇒ wrap(T2))
  wrap(struct x { T y; ... }) = struct x_wrapped { wrap(T) y; ... }

  + Question: do we need to rename struct type?

- type unwrap

# static semantics

well-defined consol specification
type checking semantics

judgment: Γ ⊢ <fun> OK

    Γ, x: t1 ⊢ pre : boolean
    Γ, x : t, y: t2 ⊢ post : boolean
    spec are of type address
    spec recur
-----------------------------------------------------------------
Γ ⊢ f(𝑥) returns (𝑦) requires pre ensures pos where specs
    function f(𝑤: t1) returns (t2) { body }


