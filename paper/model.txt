# syntax

x, f, c ∈ <id>

type := int
      | uint
      | boolean
      | address
      | mapping (T => T)
      | struct x { T x; ... }

mod := public | private // omitting external and internal

opt_decl := { (<id> : <id>)* }

spec := <id>[<opt_decl>](<id>*) returns (<id>*)
        requires <expr> ensures <expr> where <spec>*

decl := <type> <id>

fun_def = function f(<decl>*) returns (<type>*) { <stmt>; }

fun := <spec> <fun_def>

con := contract c { <decl>*; <fun>* }

value := int ∪ uint
       | true
       | false
       | <id>'('<value>*')'

opt := '{' (<id> : <expr>)* '}'

expr := <id>
      | <value>
      | <expr> op <expr>
      | <expr>'.'<id>[<opt>]'('<expr>*')'

s := <stmt>; <stmt>
   | <expr>
   | <decl> = <expr>
   | <id> = <expr>
   | if (<expr) { <stmt> } else { <stmt> }
   | return <expr>

# static semantics

well-defined consol specification
type checking semantics

judgment: Γ ⊢ <fun> OK

    Γ, x: t1 ⊢ pre : boolean
    Γ, x : t, y: t2 ⊢ post : boolean
    spec are of type address
    spec recur
-----------------------------------------------------------------
Γ ⊢ f(𝑥) returns (𝑦) requires pre ensures pos where specs
    function f(𝑤: t1) returns (t2) { body }

# translation semantics


