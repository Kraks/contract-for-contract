\section{Formal Model} \label{sec:model}

To articulate our approach and \lang's semantics, we present a core model
smart contract language \corelang equipped with
behavioral contracts. The language modulo behavioral
contracts is entirely a subset of Solidity.
This section presents \corelang's abstract syntax, static semantics, and
translation semantics.

\input{fig:syntax}

\subsection{Syntax}

\Cref{fig:syntax} shows the abstract syntax of \corelang,
which models the most important portion of Solidity.
\corelang's type contains integers, unsigned integers, booleans,
addresses, mappings, and struct.
A mapping type has the domain type and codomain type.
A struct type has a name and a list of type-and-identifier declarations.

At the top-level, a contract $c$ consists of a list of type-and-identifier
declarations and a list of function definitions.  As in other languages, a
function definition has a name, parameter declarations, return types, and the
function body.  To model boundaries between multiple smart contracts, a
function can be either \Keywd{public} or \Keywd{private}.
In \corelang, a specification $\sigma$ is additionally attached to every function.

The body of functions is simply a statement.
Statements can be a type-and-identifier declaration (without providing an initial
value), an expression (e.g. calling a function for its side effects), a
composition of two statements, an assignment, a \Keywd{return} statement, a \Keywd{revert} statement,
or a conditional statement.
The left-hand side part of assignments (i.e. assignable) can be either
a type-and-type declaration, an identifier, or a projection of mappings or structs.
Since \corelang permits both mappings and structs, which can recursively referring
other types, projection allows use to directly access nested data structures,
e.g. \code{v.field1[0].field2}.
A \Keywd{revert} statement aborts the execution, reverting any changes made to
the blockchain state.

Expressions could be an identifier, a literal value (e.g. numbers), a binary
operation, projections of mappings or structs, address calls, and function calls.
An address call has form $e_1.f\Keywd{\{}(x: e_2)^*\Keywd{\}(}e_3^*\Keywd{)}$,
where $e_1$ is the target expression of type address,
$(x: e_2)^*$ are call options (e.g. specifying the gas budget),
and $e_3^*$ are call arguments.
An ordinary function call or struct constructor call is simpler, consisting
only of the function name and argument expressions.

Specifications attached to functions first introduce bindings for the guarded
function, including the function name, option arguments, ordinary arguments,
and returned values.
The precondition and postcondition are denoted in the \code{requires}-clause and
\code{ensures}-clause, respectively.
In the \code{where}-clause, programmers can specify the condition for addresses
appeared as arguments or returned values for the parent call, recursively using
the same syntax.
In practice not all functions need to be specified with conditions.
In such cases, a no-op specification is expressed where the precondition and
postcondition are simply a boolean expression \code{true}.

\subsection{Static Semantics}

The syntax permits arbitrary expressions appeared as preconditions and
postconditions.
However, not all possible expression are valid executable specifications.
For example, a programmer can write \code{requires x + 1} as a precondition,
which do have a meaning for our purpose.
The static semantics presented here concerns about when a specification is
considered valid.

In general, the precondition and postcondition need to be well-typed, which
entails that the specified conditions are of type boolean, and only
use well-scoped variables.
Since \corelang is a subset of Solidity except for specifications, we focus on
the typing for specifications and omit the typing for the rest of the language,
referring to the informal Solidity design document.

%dynamic semantics
%\yy{do we want to model the context of contracts? (instead of reasoning one contract)}

\subsection{Translation Semantics}

\subsection{Soundness}

In this section, we discuss when and where \corelang provides the guarantee
that a violation will be detected (thus the execution of the smart contract
will be reverted).

Our translation semantics identifies the boundary


