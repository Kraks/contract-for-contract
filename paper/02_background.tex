\section{Motivation and Challenges} 
\label{sec:background}

% \todo{brief introduction of the Solidity language, why it is complicated}

In this section, 
we briefly introduce the basic concepts of blockchain and the Solidity, and
%, emphasizing their key features. 
% we first briefly introduce the background of blockchain and the Solidity language, focusing on their unique features. 
% Thereafter, we 
discuss the challenges 
% that arise when 
for designing a specification and monitoring system dedicated to Solidity.

% blockchain in a nutshell (keep it short)
% \subsubsection*{\textbf{Ethereum \& Solidity}}
% \textit{Ethereum}~\cite{buterin2014next} is a blockchain platform designed to be more flexible and programmable than its predecessor, \textit{Bitcoin}~\cite{nakamoto2008bitcoin}. 
\bfpara{Smart Contract \& Solidity.}
% Ethereum~\cite{buterin2014next} is a blockchain platform designed to  provide better flexibility 
% and programmability than its predecessor, Bitcoin~\cite{nakamoto2008bitcoin}.
% It accommodates two account types: \textit{Externally Owned Accounts} (EOAs) and 
% \textit{Smart Contracts}. EOAs, controlled by private keys, usually stand for individual users. 
Smart contracts are self-running programs running on blockchain (e.g.,~Ethereum~\cite{buterin2014next}) that enforce agreements without a third party.
Actions on Ethereum are conducted through \textit{transactions} invoking functions of smart contracts.
% , involving interactions among
% EOAs and smart contracts, e.g., an EOA invoking a function of a smart contract.
Solidity is a widely used programming language for smart contracts with a syntax similar to
Java.
In Solidity, a \code{contract} is organized akin to Java classes, containing 
executable functions and data fields that are persistent on the blockchain.
% The language enables the use of function modifiers such as \texttt{public}, which denotes that a function can be invoked by an EOA or another contract, and \texttt{private}, which suggests that the function is callable only by functions within the same contract. 
% During compilation, a contract is translated into Ethereum bytecode, which is then 
% effectively \emph{deployed} to the blockchain.

% compilation --> deployment --> address --> high-order --> open world (boundry)
% \subsubsection*{\textbf{What Special are Address?}}
% \subsubsection*{\textbf{What are Special about Addresses?}}

% GW: 1. address functionality, callback, permission, interact with other contracts, making functions higher-order
%     2. elusive vulnerability, open-world, adversarial 
%\todo{XX:explain callback function in background and what is tokens, flash loan, how nonreentranct modifier works}
% \subsubsection*{\textbf{Role of Addresses}}
\bfpara{Role of Addresses.}
Addresses in Solidity, as unique identifiers for contracts or accounts, could contain 
callable functions, providing a way to interact with other contracts and accounts.
Functions taking addresses as arguments become \emph{higher-order}, as they can induce latent behavior depending on the address arguments.
For example, addresses can be used for implementing callback, 
allowing for functions to be passed between contracts and executed as part of an atomic transaction.
% As capabilities, addresses can also be used to restrict privileged function invocations
% by distinct users with different permissions. %\xx{not clear}
%and the assignment of diverse permissions to distinct users.

However, careless use of addresses can lead to elusive vulnerabilities~\cite{dexibleHack}.
Developers have to carefully design assertions for address calls, 
examining 
under what condition the address can be invoked and 
the result of the invocation can be accepted.
Moreover, the open-world distributed execution 
% model 
of Ethereum exposes 
potentially untrusted adversarial parties without disclosed implementations.
Thus, security checks must be enforced when invoking higher-order functions depending on addresses. 
However, there are several challenges in supporting a practical behavioral contract system for Solidity. 

% \subsubsection*{\textbf{Challenge: Writing Modular, Readable Specifications}}
\bfpara{Challenge: Writing Modular, Readable Specifications.} %\xx{remove ``challenge1?'' and use title ``hard to ...''}
How do programmers write down specifications of addresses?
The ubiquitous way is to write low-level assertions.
\Cref{fig:sturby_buggy} shows such an example, where \code{require} statements in lines 4-5
are used to check the post-conditions of the address call of \code{latestRoundData()}.
However, using assertions has two major problems. First, assertions are coupled with 
a specific call and are not modularly defined.
If there are multiple calls to the same address, assertions are duplicated,
violating the ``don't repeat yourself'' principle \cite{DBLP:journals/software/X00c}.
Secondly, and perhaps more detrimentally, these assertions are often woven directly into business logic, which places a cognitive burden on programmers and thus, often worse, leads to negligence of critical checks.
As a result, the readability and maintainability of the codebase is adversely impacted.
%\yy{expanded}\todo{GW: more more more}
%problem1: not modular, for each call of address, specification has to be repeated
%problem2: interspersed with business logic

%As discussed in \Cref{sec:intro}, when passed as an argument, its latent behavior 
%remains unknown. Additionally, addresses may correspond to contracts owned by 
%other parties, making their behaviors even harder to control or predict.

%\note{addresses making functions higher-order, parametric, latent behavior}

% \subsubsection*{\textbf{Challenge: Tracking and Enforcing Address Behaviors}}
\bfpara{Challenge: Tracking and Enforcing Address Behaviors.}
Enforcing first-order behaviors for top-level functions is straightforward, e.g., using assertions or the
% Afterall, Solidity already provides the 
\code{modifier} mechanism \cite{soliditymod}
% that can be 
attached to top-level functions. 
% to perform actions before and after calls.
However, 
% \code{modifier}, or similar mechanisms, 
such mechanisms
cannot be directly applied to address calls
% Why?
because addresses are first-class values that can be used as function arguments,
return values, stored into mutable states, or escaped to other external contracts.
This unlimited flexibility presents the technical challenge of determining when 
and where to enforce address invocation specifications.
Simple syntactic identification (as \code{modifier}s) at call sites would 
not work, due to indirect value flows.
In addition, \code{modifier} mechanisms cannot check post-conditions since modifiers are only invoked before executing function bodies.
Static flow analysis \cite{DBLP:journals/pacmpl/SmaragdakisGLTT21} could identify 
the target address of calls, but it can be imprecise and expensive.
% to use for programmers.
Existing dynamic validation approaches \cite{chen2022declarative, DBLP:conf/pldi/LiCL20}
focus on contract-level global invariants, lacking 
fine-grained tracking of address behaviors and a modular way to specify 
behaviors  between functions.
% \subsubsection*{\textbf{Challenge: Gas Efficiency}}

\bfpara{Challenge: Gas Efficiency.}
Moreover, deployed smart contract programs consume a finite resource known as ``gas'', %\xx{should introduce it earlier} 
making it crucial to be efficient in tracking and enforcing address behaviors.

%These challenges pose the design question of a reasonable and effective 
%design for such a specification monitoring system.
In Section~\ref{sec:examples}, we address these challenges with \lang's design choice.

\iffalse
\begin{itemize}[leftmargin=2em]
  \item \textit{Rich higher-order computation}:
    % e.g., address are \emph{opaque first-class values carrying higher-order
    % computation}.
    Addresses are opaque first-class values carrying higher-order computation. 
    % This feature poses a challenge when it comes to monitoring and analyzing contract behavior.
  \item \textit{Distributed execution model}:
    % contracts are deployed on the blockchain and invoked remotely by an unknown
    % or adversarial party.
    Contracts deployed on the blockchain are subject to remote invocation by unknown or potentially adversarial parties. 
    % This decentralized execution model presents challenges in ensuring the security and reliability of contract interactions.
  \item \textit{Open-world assumption}:
    % we do not have access and control of all smart contract programs.
    The blockchain ecosystem operates under an open-world assumption, where access and control over all smart contract programs are limited. 
    % This necessitates careful consideration of design choices when developing specification and runtime monitoring systems.
  \item \textit{Efficiency requirement}:
    % deployed smart contract programs consumes ``gas'' and it is desirable
    % to minimize gas consumption.
    Deployed smart contract programs consume a finite resource known as ``gas'', making it crucial to optimize gas consumption while maintaining desired functionality. 
    % Striking a balance between efficiency and comprehensive monitoring poses a significant challenge.
\end{itemize}
\fi

% These challenges make it impossible to monitor all communication channels,
% which further demands us exploring different design choices when layering
% a specification and runtime monitoring system for Solidity.
%Given these challenges, it is clear that attempting to monitor all communication channels within this environment is infeasible. 
%Consequently, the development of specification and runtime monitoring systems for Solidity necessitates the exploration of various design approaches.


%\todo{GW: challenge, talk about what doesn't work, static flow analysis, approximation, syntactic identification of call sites, not precise; callback}

%Owing to these challenges, traditional static analysis tools struggle to 
%effectively enforce address behavior.

%Dynamically tracking\xx{tracking <-> persistent} the usage of addresses 
%(which may be passed as integers) poses technical challenges, 
%making it a demanding yet essential area to explore.

%\xx{--------split-----------}

\iffalse
\todo{GW: talk about why it is necessary and challenging to enforce address behaviors} 
\todo{A pervasive (commonly used) -> callback, B may contain elusive vuln. (1.intro 2. could be other parties' contract therefore out of control. C refer to challenges, existing work (runtime approach) don't work because dynamically track the use of address (a integer) is a technical challenge}
\todo{GW: challenge, talk about what doesn't work, static flow analysis, approximation, syntactic identification of call sites, not precise; callback}
Both EOAs and smart contracts can be identified by a unique 160-bit address. 
% The address of an EOA is computed from its private key, while the address of a smart contract is determined by its deployment procedure. 
In Solidity, these addresses not only exist as first-class values but are also callable 
entities capable of carrying out complex computations. 

Let us revisit the example in \Cref{fig:intro_example} with a bit more details about how addresses are used in Solidity. 
\note{GW: missing a high-level intuitive description of what this example does?}
The example begins with the definition of an interface \texttt{IERC20},
specifying a function \texttt{transferFrom} (lines 1-3). 
% In Solidity, cross-contract calls operate akin to remote procedure calls, where the callee function is dynamically resolved and chosen at the receiver contract's runtime, requiring only the interface rather than the implementation during compilation.
It is noteworthy that in Solidity, cross-contract calls operate akin to remote procedure calls, 
where only the interface is required at compile-time.
% Following this, a smart contract, \texttt{Vault}, is outlined, which includes a data field \texttt{owner} (line 6), a constructor (line 8), and a function \texttt{deposit} (lines 10-14). 
The \code{Vault} contract is comprised of an \code{owner} data field (line 6), 
the constructor (line 8), and a function dubbed \code{deposit} (lines 10-14). 
The constructor, triggered during the contract's deployment, assigns the sender's address (\code{msg.sender}) to \code{owner}.
The \code{deposit} function (line 10), accepting two arguments \code{token} and \code{amount}, is a prime example of addresses:
\code{token} represents an address of a smart contract deployed by another party whose implementation is unavailable. 
The \code{require} statement at line 11 ensures the sender is the contract's owner. 
A function call to \code{transferFrom} is subsequently invoked once the address \code{token} is cast to conform to \code{IERC20} (lines 12-13).
\fi

%Nevertheless, given the potential existence of adversarial actors creating and 
%deploying their own contracts, thorough 

%Addresses are also capable of being called upon and conducting arbitrary computations.
%This attribute allows contracts to interact flexibly with other contracts, even if 
%Consequently, the ecosystem of smart contracts can evolve incrementally in a decentralized fashion,
%with various developers contributing via the deployment of their distinct contracts.
%Subsequent developers can effortlessly interact with pre-existing contracts by
%invoking their functions using addresses.

% XXX For example, a smart contract can call an external function of another smart contract using the address of the latter.
% As shown above, the function \texttt{f} takes an address as an argument and calls the transfer function of the contract at the given address. 
% Note that \texttt{IERC20} is an interface, which helps the compiler to generate the correct signatures for the function call.
% By doing so, a smart contract can interact with other smart contracts without knowing their implementations.
% It is also noteworthy that it is common to use an address of a smart contract that is deployed by others, which is beyond the control of the current contract. 
% As long as the subject contract implements the interface, the current contract can call its functions.
% Besides, Solidity treats addresses as first-class values, which can be passed as arguments, returned as results, stored in data fields, and so on.


% + introduce solidity in a nutshell
% + focus on address: first-class and high-order, basic access control
% + do we need to talk about modifiers?
% + gas - halting problem


% gas --> halting problem


% address: they are callable and can perform arbitrary computation, but we cannot always
% inspect the computation other than checking the underlying numeric addressing value.

%\subsubsection*{\textbf{Challenges}}
% Here we identify some major challenges imposed by the unique features of blockchain computation and the Solidity language: 
%Overall, we see unique challenges in developing a specification language and runtime monitoring
%system for Solidity and blockchain computation.
%These challenges arise from the distinctive features inherent in this domain:
%\note{GW: need revisit this part later}

% \zz{whether it is intuitive to see the challenges from the features?}









