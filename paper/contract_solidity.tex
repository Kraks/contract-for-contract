\section{\lang by Examples}

We now introduce \lang informally with examples.
\lang is a non-breaking extension that additionally provides means
to specify behavioral contracts on top of the Solidity language.
We often use (executable) \emph{specification} for behavioral contracts to avoid terminological ambiguity.

\paragraph{Design Rationale}
This paper concerns about designing an extension for Solidity that enhances the
language with contracts for higher-order temporal behaviors.
The extension should be
\begin{itemize}
  \item non-intrusive
  \item expressive
  \item gradual (you do not need to pay the overhead if you don't use contracts)
  \item efficient (no or little overhead)
\end{itemize}

\subsection{Contracts for First-Order Values}

We begin with specifying precondition and postcondition for functions
involving first-order values. Consider the following \code{toEither} example
that converts \note{Wei?} to Either:
\begin{lstlisting}[language=Solidity]
# toEither(x) returns (y)
# requires x % 1e18 < 1e17
# ensures  y < type(uint).max / 1e18
function toEther(uint x) returns (uint y) { ... }
\end{lstlisting}

The first line introduces bindings for \code{toEither}'s arguments and return
values, which are \code{x} and \code{y}, respectively.
The binding names in the specification do not have to match those in the function definition.
The \code{requires}-clause specifies the precondition to call \code{toEither},
and the \code{ensures}-clause specifies the postcondition.
Any occurrences of \code{x} in the \code{requires}-clause refer to the actual
argument value, and similarly, occurrences of \code{y} in the \code{ensures}-clause
refer to the actual returned value.

\paragraph{Syntactic Sugars}
We can liberally omit any part of the argument or return value specification:
\begin{lstlisting}
# toWei(x) returns (_)
# ensures x < type(uint).max / 1e18
function toWei(uint x) returns (uint) { ... }
\end{lstlisting}
which is equivalent to core form where the omitted part is simply the boolean expression
\code{true}:
\begin{lstlisting}[language=Solidity]
# toWei(x) returns (_)
# ensures x < type(uint).max / 1e18
# requires true
\end{lstlisting}

\paragraph{Dependent Contract}
Postconditions can depend on the argument as well. In other words,
the scope of arguments span over both the precondition and postcondition.
For example, the following snippet is a valid postcondition that requires
monotonicity.
\begin{lstlisting}
# f(x) returns (y) ensures y > x
\end{lstlisting}

%Another way is to use the `any` flat contract, which is defined as
%\code{any = { _ | true }}:
%\begin{lstlisting}
%  # {x | x < type(uint).max / 1e18} -> any
%\end{lstlisting}

\paragraph{Any Expression is Allowed}
When specifying the pre-/postconditions of functions, the programmer can use
any valid Solidity expression to from the condition, including but not limited
to function calls, memory operations, and built-in special variables carrying
important transaction data (e.g. \code{msg.value}) or metadata (e.g.
\code{block.timestamp}) that are only available at runtime.
The programmers are free to check desired conditions against with these
transactional information.
For example, the following snippet examines \code{msg.value} as the
precondition of a payable function:
\begin{lstlisting}
# byTickets(n) ensures msg.value >= 1e15 * n
function buyTickets(int n) payable { ... }
\end{lstlisting}
With this kind of flexibility and expressiveness, programmers are able to
express invariants beyond the capability of static verification.
%\zz{How about other special variables, such as `block.chainid` and `tx.origin`?. Perhaps we could redesign a universal syntax for these variables in Section 2.5, where we discuss where to add the message sender}
%\url{https://docs.soliditylang.org/en/develop/units-and-global-variables.html#block-and-transaction-properties}

So far, these flat contracts for first-order values are straightforward,
and can be directly mapped to assertions wrapping around functions.

\subsection{Contracts for Higher-Order Values}

\paragraph{Addresses}
Resembling pointers in C/C++, addresses in Solidity are numerical values
that can be compared or \note{computed?}.
In this sense, specifications of addresses are no different
from other integer values.
For instance, the following specification requires that
the address argument value cannot be 0:
\begin{lstlisting}
# f(addr) requires addr == 0
function f(address payable addr) { ... }
\end{lstlisting}

However, addresses in Solidity have rich higher-order behaviors: they may
represent a deployed external Ethereum contract and can be invoked in
customized ways.
For example, the following snippet shows a function \code{f} taking an address
\code{addr} that is called at some point.
The programmer intends to the specify the precondition and postcondition when
calling \code{addr}. \note{GW: explain abi?}
Nevertheless, such checks against \code{addr} cannot be performed when \code{f}
is called, even though \code{addr} is a proper argument of \code{f}.
Because \code{addr} in this use case is effectively a function, and
it is undecidable to statically examine its properties in general.
Additionally, we may not have access to the source code of the contract
represented by \code{addr}.
\note{GW: could use a simpler example, and discuss low-level call in the next paragraph section}
\begin{lstlisting}
# f(addr) where
# { addr.call(msg, amount) returns (flag, data)
#   requires amount > 100
#   ensures flag == true }
function f(address payable addr) {
  ... // omitting statements before the call
  (bool success, bytes memory data) =
    addr.call(abi.encodeWithSignature(
        "foo(string, uint256)", "call foo", 128
      )
    );
  ... // omitting statements after the call
}
\end{lstlisting}
\lang addresses this issue by adopting lazy checks
\cite{DBLP:conf/icfp/FindlerF02} that only take place
when the address is actually invoked \note{GW: fwd ref to impl}.
The above snippet specifies the condition of \code{addr}
in the \code{where}-clause, which requires
the \code{amount} argument must be greater than 100 and
the address call must succeed.

Notably, using \lang we have separated the concern of specifications and usages
--- there is no need to change the function body or manually insert checks
around the call. This leads to more maintainable code and allows programmers to
fearlessly refactor the code.

\paragraph{Single Address, Multiple Callees}
Multiple callees can inhabit in a single address value.
Other than the \code{call} method, there are other forms of low-level calls with
different signatures, e.g., \code{delegatecall}, \code{send}, etc.
% https://docs.soliditylang.org/en/v0.8.20/units-and-global-variables.html#address-related
Programmers can specify conditions for different callee targets in the
\code{where}-clause.
\begin{lstlisting}
# f(addr) where
# { addr.send(x) returns (succ) requires ... }
# { addr.call(msg, x) returns (succ, data) requires ... }
\end{lstlisting}

\zz{I guess we should educate the audience about the difference between low-level and high-level calls at the beginning of Section 2.4. I'll take care of this later.}
\note{GW: it seems we need to discern \code{call}s with different signatures}

\paragraph{Additional Arguments}
Solidity address calls can take additional special arguments
such as \code{value} and \code{gas}:
\begin{lstlisting}
addr.call{value: msg.value, gas: 5000}(...);
\end{lstlisting}
In \lang, programmers can specify their conditions by introducing additional
bindings using the familiar syntax:
\begin{lstlisting}
# addr.call{value: v, gas: g}(msg, amount) ...
\end{lstlisting}
\code{v} and \code{g} represent the actual message value and gas
value, which can be used in \code{requires}/\code{ensures}-clauses.

\iffalse
It would be convenient to directly enforces the success of the call and omit
the data:
\begin{lstlisting}
  # { a | { {value, gas}(arg) | <pre-cond> } -> { (true, _) | true } }
  function f(address a) { ... }
\end{lstlisting}

\zz{just FYI, `a.f` can also specify `value`, `gas`, etc.}

\begin{lstlisting}
  # { a.f | pre-cond -> post-cond }
  # { a.g | pre-cond -> post-cond }
  function f(address a) { ... }
\end{lstlisting}

\wac{We may need an example here since the necessity to designate the callee function may not be obvious to reviewers.}
\fi

\paragraph{Second-Class Monitoring}
%\note{GW: an easy option is to discard enforcement of escaped addresses at all.
%But it seems we can guard escaped addresses within the current contract scope.
%We need to think about layered/stacked contracts of addresses (lax/picky).}
Addresses, as first-class values, can of course escape from a function, e.g.
by returning from the function or storing in external data structures.
However, it is not always possible to enforce the specification
of addresses when escaped to third-parties.
For example, consider a function that returns an address equipped with
conditions:
\begin{lstlisting}
EXAMPLE TODO
function f(address a) returns (address) { return a; }
\end{lstlisting}
In this case, if the returned address value crosses the boundary to other
Ethereum programs (by external calls initiated by a third-party) that we do not
have control, we are impotence to monitor if the conditions are violated.

In spite of that, \lang does guarantee that addresses are completely monitored
within the current Ethereum program's calling context, following a stack
discipline.
In other words, for an argument addresses \code{addr} of function \code{f},
\lang is able to detect any violation of \code{addr}'s conditions before
\code{f} returns (even if the call happens in other functions).
We called this mechanism \emph{second-class monitoring}, borrowing Strachey's taxonomy
of first- and second-class objects \cite{DBLP:journals/lisp/Strachey00}.
This is already useful to prevent \note{XXX} \note{fwd ref}, especially when
the address comes from an untrusted party.

Similarly, when a guarded address is used as an argument to another address
call, \note{we lose the control of ...}

\paragraph{Notes on Function Pointers}
Likewise, functions in Solidity are first-class values, i.e., they can be used
as arguments of functions and returned from functions.
However, at this moment \footnote{Solidity version 8.20} there is no way to
write anonymous functions (lambda expressions) or nested, named functions that
capture variables from environments.
Only explicitly defined top-level functions can be used in ``first-class'' ways.
This restriction prohibits real closure values following lexical scopes,
familiarized by functional programmers.
%This restriction discourages programmers to use higher-order functions due to
%its inconvenience and verbosity.
Moreover, it poses challenges to seamlessly implement first-class behavioral
contract and monitor system that guards higher-order functions (e.g. as in
\cite{DBLP:conf/icfp/FindlerF02}) without an expensive whole program
transformation.
Therefore, in this paper we focus on the contract and monitoring of addresses
values and leave monitoring for higher-order functions as future work when
Solidity has a proper support for lambda expressions.

\iffalse
	\begin{lstlisting}
function map(uint[] memory data, function (uint) pure returns (uint) f)
  internal pure returns (uint[] memory r)
{
  r = new uint[](data.length);
  for (uint i = 0; i < data.length; i++) {
    r[i] = f(data[i]);
  }
}
\end{lstlisting}

We can specify the contract for function arguments too:
\begin{lstlisting}
  # { f | {x | x < 0} -> {y | y > 0} }
  function map(int[] memory data, function (int) pure returns (int) f) { ... }
\end{lstlisting}
It might be too verbose -- so we can define those predicates separately for better readability/maintainability:
\begin{lstlisting}
  function greaterThanZero(int x) pure returns (bool) {
    return x > 0;
  }
  function smallerThanZero(int x) pure returns (bool) {
    return x < 0;
  }
  # { f | smallerThanZero -> greaterThanZero }
  function map(int[] memory data, function (int) pure returns (int) f) { ... }
\end{lstlisting}

Functions contracts can be higher-order --
it can take other function contracts
as part of the spec. For example
\zz{coooool!}
\begin{lstlisting}
  # TODO
  function f(function (function (int) returns (int) g) h) { ... }
\end{lstlisting}

Function contracts are first-class -- so if this guarded function is escaped
(e.g. by returning), the contract is still enforced:
\begin{lstlisting}
NEED AN EXAMPLE
\end{lstlisting}
\fi

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "paper"
%%% End:
