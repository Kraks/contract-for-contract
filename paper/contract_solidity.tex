\section{\lang by Examples}

We now introduce \lang informally with examples.
\lang is a non-breaking extension that additionally provides means
to specify behavioral contracts on top of the Solidity language.
We often use (executable) \emph{specification} for behavioral contracts to avoid terminological ambiguity.

\paragraph{Design Rationale}
This paper concerns about designing an extension for Solidity that enhances the
language with contracts for higher-order temporal behaviors.
The extension should be
\begin{itemize}
  \item non-intrusive
  \item expressive
  \item gradual (you do not need to pay the overhead if you don't use contracts)
  \item efficient (no or little overhead)
\end{itemize}

\subsection{Contracts for First-Order Values}

We begin with specifying precondition and postcondition for functions
involving first-order values. Consider the following \code{toEither} example
that converts \note{Wei?} to Either:
\begin{lstlisting}[language=Solidity]
# toEither(x) returns (y)
# requires x % 1e18 < 1e17
# ensures  y < type(uint).max / 1e18
function toEther(uint x) returns (uint y) { ... }
\end{lstlisting}

The first line introduces bindings for \code{toEither}'s arguments and return
values, which are \code{x} and \code{y}, respectively.
The binding names in the specification do not have to match those in the function definition.
The \code{requires}-clause specifies the precondition to call \code{toEither},
and the \code{ensures}-clause specifies the postcondition.
Any occurrences of \code{x} in the \code{requires}-clause refer to the actual
argument value, and similarly, occurrences of \code{y} in the \code{ensures}-clause
refer to the actual returned value.

\paragraph{Syntactic Sugars}
We can liberally omit any part of the argument or return value specification:
\begin{lstlisting}
# toWei(x) returns (_)
# ensures x < type(uint).max / 1e18
function toWei(uint x) returns (uint) { ... }
\end{lstlisting}
which is equivalent to core form where the omitted part is simply the boolean expression
\code{true}:
\begin{lstlisting}[language=Solidity]
# toWei(x) returns (_)
# ensures x < type(uint).max / 1e18
# requires true
\end{lstlisting}

\paragraph{Dependent Contract}
Postconditions can depend on the argument as well. In other words,
the scope of arguments span over both the precondition and postcondition.
For example, the following snippet is a valid postcondition that requires
monotonicity.
\begin{lstlisting}
# f(x) returns (y) ensures y > x
\end{lstlisting}

%Another way is to use the `any` flat contract, which is defined as
%\code{any = { _ | true }}:
%\begin{lstlisting}
%  # {x | x < type(uint).max / 1e18} -> any
%\end{lstlisting}

\paragraph{Any Expression is Allowed}
When specifying the pre-/postconditions of functions, the programmer can use
any valid Solidity expression to from the condition, including but not limited
to function calls, memory operations, and built-in special variables carrying
important transaction data (e.g. \code{msg.value}) or metadata (e.g.
\code{block.timestamp}) that are only available at runtime.
The programmers are free to check desired conditions against with these
transactional information.
For example, the following snippet examines \code{msg.value} as the
precondition of a payable function:
\begin{lstlisting}
# byTickets(n) ensures msg.value >= 1e15 * n
function buyTickets(int n) payable { ... }
\end{lstlisting}
With this kind of flexibility and expressiveness, programmers are able to
express invariants beyond the capability of static verification.
%\zz{How about other special variables, such as `block.chainid` and `tx.origin`?. Perhaps we could redesign a universal syntax for these variables in Section 2.5, where we discuss where to add the message sender}
%\url{https://docs.soliditylang.org/en/develop/units-and-global-variables.html#block-and-transaction-properties}

So far, these flat contracts for first-order values are straightforward,
and can be directly mapped to assertions wrapping around functions.

\subsection{Contracts for Higher-Order Values}

\paragraph{Addresses}
Resembling pointers in C/C++, addresses in Solidity are numerical values
that can be compared or \note{computed?}.
In this sense, specifications of addresses are no different
from other integer values.
For instance, the following specification requires that
the address argument value cannot be 0:
\begin{lstlisting}
# f(addr) requires addr == 0
function f(address payable addr) { ... }
\end{lstlisting}

However, addresses in Solidity have rich higher-order behaviors: they may
represent a deployed external Ethereum contract and can be invoked in
customized ways.
For example, the following snippet shows a function \code{f} taking an address
\code{addr} that is called at some point.
The programmer intends to the specify the precondition and postcondition when
calling \code{addr}. \note{GW: explain abi?}
Nevertheless, such checks against \code{addr} cannot be performed when \code{f}
is called, even though \code{addr} is a proper argument of \code{f}.
Because \code{addr} in this use case is effectively a function, and
it is undecidable to statically examine its properties in general.
Additionally, we may not have access to the source code of the contract
represented by \code{addr}.
\note{GW: could use a simpler example, and discuss low-level call in the next paragraph section}
\begin{lstlisting}
# f(addr) where
# { addr.call(msg, amount) returns (flag, data)
#   requires amount > 100
#   ensures flag == true }
function f(address payable addr) {
  ... // omitting statements before the call
  (bool success, bytes memory data) =
    addr.call(abi.encodeWithSignature(
        "foo(string, uint256)", "call foo", 128
      )
    );
  ... // omitting statements after the call
}
\end{lstlisting}
\lang addresses this issue by adopting lazy checks
\cite{DBLP:conf/icfp/FindlerF02} that only take place
when the address is actually invoked \note{GW: fwd ref to impl}.
The above snippet specifies the condition of \code{addr}
in the \code{where}-clause, which requires
the \code{amount} argument must be greater than 100 and
the address call must succeed.

Notably, using \lang we have separated the concern of specifications and usages
--- there is no need to change the function body or manually insert checks
around the call. This leads to more maintainable code and allows programmers to
fearlessly refactor the code.

\paragraph{Single Address, Multiple Callees}
Multiple callees can inhabit in a single address value.
Other than the \code{call} method, there are other forms of low-level calls with
different signatures, e.g., \code{delegatecall}, \code{send}, etc.
% https://docs.soliditylang.org/en/v0.8.20/units-and-global-variables.html#address-related
Programmers can specify conditions for different callee targets in the
\code{where}-clause.
\begin{lstlisting}
# f(addr) where
# { addr.send(x) returns (succ) requires ... }
# { addr.call(msg, x) returns (succ, data) requires ... }
\end{lstlisting}

\zz{I guess we should educate the audience about the difference between low-level and high-level calls at the beginning of Section 2.4. I'll take care of this later.}
\note{GW: it seems we need to discern \code{call}s with different signatures}

\paragraph{Additional Arguments}
Solidity address calls can take additional special arguments
such as \code{value} and \code{gas}:
\begin{lstlisting}
addr.call{value: msg.value, gas: 5000}(...);
\end{lstlisting}
In \lang, programmers can specify their conditions by introducing additional
bindings using the familiar syntax:
\begin{lstlisting}
# addr.call{value: v, gas: g}(msg, amount) ...
\end{lstlisting}
\code{v} and \code{g} represent the actual message value and gas
value, which can be used in \code{requires}/\code{ensures}-clauses.

\iffalse
It would be convenient to directly enforces the success of the call and omit
the data:
\begin{lstlisting}
  # { a | { {value, gas}(arg) | <pre-cond> } -> { (true, _) | true } }
  function f(address a) { ... }
\end{lstlisting}

\zz{just FYI, `a.f` can also specify `value`, `gas`, etc.}

\begin{lstlisting}
  # { a.f | pre-cond -> post-cond }
  # { a.g | pre-cond -> post-cond }
  function f(address a) { ... }
\end{lstlisting}

\wac{We may need an example here since the necessity to designate the callee function may not be obvious to reviewers.}
\fi

\paragraph{Second-Class Monitoring}
%\note{GW: an easy option is to discard enforcement of escaped addresses at all.
%But it seems we can guard escaped addresses within the current contract scope.
%We need to think about layered/stacked contracts of addresses (lax/picky).}
Addresses, as first-class values, can of course escape from a function, e.g.
by returning from the function or storing in external data structures.
However, it is not always possible to enforce the specification
of addresses when escaped to third-parties.
For example, consider a function that returns an address equipped with
conditions:
\begin{lstlisting}
EXAMPLE TODO
function f(address a) returns (address) { return a; }
\end{lstlisting}
In this case, if the returned address value crosses the boundary to other
Ethereum programs (by external calls initiated by a third-party) that we do not
have control, we are impotence to monitor if the conditions are violated.

In spite of that, \lang does guarantee that addresses are completely monitored
within the current Ethereum program's calling context, following a stack
discipline.
In other words, for an argument addresses \code{addr} of function \code{f},
\lang is able to detect any violation of \code{addr}'s conditions before
\code{f} returns (even if the call happens in other functions).
We called this mechanism \emph{second-class monitoring}, borrowing Strachey's taxonomy
of first- and second-class objects \cite{DBLP:journals/lisp/Strachey00}.
This is already useful to prevent \note{XXX} \note{fwd ref}, especially when
the address comes from an untrusted party.

Similarly, when a guarded address is used as an argument to another address
call, \note{we lose the control of ...}

\paragraph{Notes on Function Pointers}
Likewise, functions in Solidity are first-class values, i.e., they can be used
as arguments of functions and returned from functions.
However, at this moment \footnote{Solidity version 8.20} there is no way to
write anonymous functions (lambda expressions) or nested, named functions that
capture variables from environments.
Only explicitly defined top-level functions can be used in ``first-class'' ways.
This restriction prohibits real closure values following lexical scopes,
familiarized by functional programmers.
%This restriction discourages programmers to use higher-order functions due to
%its inconvenience and verbosity.
Moreover, it poses challenges to seamlessly implement first-class behavioral
contract and monitor system that guards higher-order functions (e.g. as in
\cite{DBLP:conf/icfp/FindlerF02}) without an expensive whole program
transformation.
Therefore, in this paper we focus on the contract and monitoring of addresses
values and leave monitoring for higher-order functions as future work when
Solidity has a proper support for lambda expressions.

\iffalse
	\begin{lstlisting}
function map(uint[] memory data, function (uint) pure returns (uint) f)
  internal pure returns (uint[] memory r)
{
  r = new uint[](data.length);
  for (uint i = 0; i < data.length; i++) {
    r[i] = f(data[i]);
  }
}
\end{lstlisting}

We can specify the contract for function arguments too:
\begin{lstlisting}
  # { f | {x | x < 0} -> {y | y > 0} }
  function map(int[] memory data, function (int) pure returns (int) f) { ... }
\end{lstlisting}
It might be too verbose -- so we can define those predicates separately for better readability/maintainability:
\begin{lstlisting}
  function greaterThanZero(int x) pure returns (bool) {
    return x > 0;
  }
  function smallerThanZero(int x) pure returns (bool) {
    return x < 0;
  }
  # { f | smallerThanZero -> greaterThanZero }
  function map(int[] memory data, function (int) pure returns (int) f) { ... }
\end{lstlisting}

Functions contracts can be higher-order --
it can take other function contracts
as part of the spec. For example
\zz{coooool!}
\begin{lstlisting}
  # TODO
  function f(function (function (int) returns (int) g) h) { ... }
\end{lstlisting}

Function contracts are first-class -- so if this guarded function is escaped
(e.g. by returning), the contract is still enforced:
\begin{lstlisting}
NEED AN EXAMPLE
\end{lstlisting}
\fi

\subsection{Contracts for Temporal Behaviors}

Temporal contracts relate two function calls (events) and enforces their
relation.
They can inspect the time-stamps, message sender, arguments, return values
of the two function calls.

\todo{where to add message sender? proposed syntax:}
\begin{lstlisting}
  # ts1 \code{ f(x) returns z from sdr1 => ts2 } g(a) returns c from sdr2
\end{lstlisting}
\begin{lstlisting}
  # f(x) returns z => g(a) returns c /\ f.msg.sender == g.msg.sender
\end{lstlisting}
\wac{\texttt{msg.sender} is better tied with transaction. We can use ts1.msg.sender and I prefer to put the constraints in the side-cond. }

\subsubsection{Positive Temporal Properties}

Positive temporal properties enforces that an event must happen
after another event. Syntax:
\begin{lstlisting}
  # ts1 \code{ f(x) returns z => ts2 } g(a) returns c /\ side-cond
\end{lstlisting}
It enforces that when \code{g} is invoked, we check \code{f} has invoked \emph{and}
the side-condition is evaluated to true.
We do not enforce that \code{g} will be invoked eventually after invoking \code{f}.

Side conditions can be arbitrary expressions that uses the time-stamps, message
sender, arguments, return values of the two function calls.
For example, the following spec passes arguments of \code{f} and \code{g} into
another function for checking:

\begin{lstlisting}
  # ts1 \code{ f(x) returns z => ts2 } g(a) returns c /\ check(x, a)
\end{lstlisting}

If a variable occurs in both events, an additional equality constraint
is synthesized.  For example,
\begin{lstlisting}
  # ts1 \code{ f(x) returns z => ts1 } g(z) returns c
\end{lstlisting}
requires that both function \code{f} and \code{g} happen in the same transaction,
and the return value of \code{f} is the same as the argument of \code{g}.
It will be translated to the core syntax as the following:
\begin{lstlisting}
  # ts1 \code{ f(x) returns z => ts2 } g(y) returns c /\ ts1 == ts2 && x == y
\end{lstlisting}

It is totally fine to omit the time-stamp, arguments, or return values.
Simply requiring \code{f} happens before \code{g}:
\begin{lstlisting}
  # f => g
  function f(...) { ... }
\end{lstlisting}

\todo{need to think about quantification.}

Note: \code{f => g} matches the most recent call of \code{f},
or any prior call of \code{f} (if there are multiple calls of \code{f})?

\todo{need to think about interactions with compiler optimization (eg inlining).}

\todo{need to think about how temporal contracts interact with address calls.}

\subsubsection{Negative Temporal Properties}

Negative temporal properties enforces that an event must \emph{not}
happen after another event.

\begin{lstlisting}
  # ts1 \code{ f(x) returns z =/> ts2 } g(a) returns c /\ side-cond
\end{lstlisting}
It enforces that when \code{g} is invoked \emph{and} the side condition
evaluates to true, we check that \code{f} has not been invoked.

We do not enforce that \code{g} cannot be invoked eventually
after invoking \code{f}.

For example, the following spec enforces that \code{g} cannot be
invoked after \code{f} using \code{z} as the argument:
\begin{lstlisting}
  # ts1 \code{ f(x) returns z =/> ts2 } g(z) returns c
  //or equivalently
  # ts1 \code{ f(x) returns z =/> ts2 } g(y) returns c /\ x == y
\end{lstlisting}
However it is okay to call \code{g} after \code{f} with an argument different from \code{z}.

\subsubsection*{Affine Use}

Using negative temporal contracts, we can enforce affine use, i.e.
a function can be called at most once.
\begin{lstlisting}
  # f =/> f
  function f(int x) { ... }
\end{lstlisting}
If \code{f} has been called before (and the call is finished), any
call to \code{f} afterwards is prohibited.

\note{could further discern different timestamps/senders}

%linear (must call once),
%relevant (at least call once)

\subsection{Contextual Properties}

Contextual contracts inspect the calling-context/stack within the
current smart contract.

\note{Related work: stack inspection. But we don't need to modify the runtime
	of EVM, but simply record a shadow stack for necessary metadata. Is that enough?}

\subsubsection{Positive Contextual Properties}

For example, the following spec enforces that \code{g} can only be invoked
under the calling context of \code{h}, and the return value of \code{h} must be
the same as the argument of \code{g}:

\begin{lstlisting}
  function h(int x) returns int { ... }
  # h(x) returns y ~> g(y) returns r
  function g(int y) returns int { ... }
\end{lstlisting}

To enforce this behavioral contracts, we must check
\begin{itemize}
	\item when \code{g} is invoked, there is a frame of \code{h} on the stack,
	\item when \code{h} returns (which happens after \code{g} returns), the return value
	      is the same as the argument of \code{g}.
\end{itemize}

Question: what if \code{g} is invoked multiple times under the same calling context of
\code{h}?

Solution: need quantifier. A simple/default solution is to check all
invocations of \code{g}.

Question: what if there are multiple call frames of \code{h} on the stack?

Solution: need quantifier. A simple/default solution is to only check
the most recent call frame of \code{h} on the stack.

\wac{I think the previous definition of contextual property $h ~> g$ means $\forall g, \exists h$ implicitly, i.e., for any $g$ called, there must exist one $h$ on the call stack. I cannot think of a use scenario where quantifiers on $h$ and $g$ are needed in practice.}
\wac{If we want to distinguish different call frames of $h$ and $g$, maybe it's better to design activation constraints for the contextual properties, e.g., \texttt{cond -> h ~> g}, meaning $h ~> g$ is only enforced when $cond$ is true (imply). ps: the special arrow is broken outside the listing environment. :(}

\subsubsection{Negative Contextual Properties}

The following program is a violation of non-reentrancy:

\begin{lstlisting}
  # non-reentrant
  function f(uint x) { f(n) }
\end{lstlisting}

This is an example of negative contextual properties, i.e. something cannot
happen under the current calling context. Under the neath, this spec is
equivalent to

\begin{lstlisting}
  # f ~/> f
  function f(uint x) { f(n) }
\end{lstlisting}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "paper"
%%% End:
