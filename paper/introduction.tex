\section{Introduction} \label{sec:intro}

%https://se.inf.ethz.ch/~meyer/publications/old/dbc_chapter.pdf
%https://docs.soliditylang.org/en/v0.8.17/control-structures.html?highlight=require#panic-via-assert-and-error-via-require

%\todo{why? solidity is rather flexible, unsatisfying/weaker type system,
%not all invariants can be checked statically, e.g. the status of the chain}
%One \note{common} use case of higher-order functions in smart contracts is
%to express callback \todo{explain how it is used}.

%\todo{it is hard to enforce properties when callbacks exist}
%Static verification cannot completely address the issue here since
%transaction developers are oblivious to the user-provided callback.

%Building trustworthy and secure smart contract programs requires solid
%understanding and reliable enforcement of program invariants.

Smart contracts are programs to automate the execution of transactional agreements so that all
parties involved in the agreement can be certain about the outcome.
Smart contract programs run on blockchains, implementing a consensus
protocol of Byzantine-fault-tolerant distributed ledgers.
By using blockchains, smart contracts are ``smart'' since they are an
mechanism to \emph{ensure the economic outcome of transactions} without a
central authority.

It is however ironic that despite the potential of popular smart contract
\emph{languages}, they often lack adequate mechanisms to ensure the
computational outcomes.  This unfortunate reality results in unsatisfactory
quality of smart contract programs. Without proper means to ensure the quality
of these programs, the aspiration to ensure the economic outcome of
transactions remains nothing more than a mere wish.

Undoubtedly, the past few years have witnessed several catastrophic failures
of blockchain systems resulting from attacks on vulnerable contract programs.
One prominent instance is the well-known DAO hack~\cite{DAOhack} where an unauthorized
attacker exploited the recursive function calls and callback mechanism, leading
to a staggering loss of \textdollar50 million. The fundamental issue at the core of this
attack was the failure of the deployed contract to prevent reentrancy under
critical conditions.

%\zz{ On the other hand, assertion primitives are crucial for ensuring the
%accuracy and integrity of a smart contract's business model. }
%\zz{ I'm not sure if this statement applies to the PL community, but from my
%understanding, assertions are typically used during testing rather than
%runtime.  However, in smart contracts, these assertions function as guard
%conditions and can cause reverts if violated, making them extremely important. }

%Solidity also provides the @modifier@ mechanism that intercepts
%before and after a function call, thus can be used to check
%pre- and post-conditions.
%\todo{can we compose modifier?}
%\todo{can we attach modifier to callbacks?}
%\todo{can we use modifier to check function's argument?}

To prevent such attacks, the programmer needs to specify those critical
conditions. The execution is allowed only when those conditions are met.
However, we observe that existing popular smart contract languages (e.g.,
Solidity) do not provide \emph{expressive, effective, convenient} means to
\emph{specify} and \emph{enforce} contract behaviors.
Simple first-order assertion primitives are indeed available, but they cannot
effectively examine callable addresses or function values,
%\zz{are function values referring to high-order functions?}
which exhibit
higher-order behaviors and are a common pattern used in developing smart contract
programs.
%Moreover, many of the critical conditions in smart contracts are \emph{temporal}
%-- the order of events matters.
%For instance, to defense the DAO attack caused by reentrancy via
%external functions, it requires to check that the function of interest cannot
%be invoked \emph{before} the current call of the same function is finished.
The lack of sufficient linguistic means to specify and enforce subtle but
critical behaviors discourages programmers to write clean and maintainable
code with higher-level abstractions.
Instead, programmers are obliged to write verbose low-level code
to implement security checks, which conflates the main business logic with
behavioral checks, further leading to poor readability and maintainability.
%The pervasive temporal conditions in distributed blockchain systems further
%complicates the situation: these temporal behavioral checks are usually
%encoded as value-level checks in ad-hoc manners.
%Taking the DAO attack as example again, a common way to implement ``reentrancy
%guards'' is to manually define an additional boolean flag, indicating
%whether the function is finished. This is both verbose and error-prone,
%quickly becoming unmanageable for complex behaviors.
And often worse, defensive checks are forgotten or disregarded, leading to
vulnerable code causing real monetary loss.
\todo{need a concrete motivating example?}

%Apart from the investigating effort to certify and verify smart contract
%programs, language designers are responsible to empower programmers with better
%linguistic solutions to secure smart contracts in the first place.
To address these issues, we argue that \emph{behavioral software
contracts}~\cite{DBLP:conf/tools/Meyer98a} should play a fundamental role in
the development of \emph{smart contract} programs.
Similar to smart contracts, behavioral contracts is an agreement, too. They
specify assumptions and guarantees between software components, just as
smart contracts specify assumptions and guarantees between economic parties.

Behavioral contracts are appealing to programmers since the specified
assumptions and guarantees are executable specifications written in the same
programming language syntax, and will be monitored and reported if violated.
Pioneered by the Eiffel language \cite{DBLP:books/ph/Meyer91} and the
design-by-contract methodology \cite{DBLP:conf/tools/Meyer98a,
DBLP:books/ph/Meyer97}, various styles of behavioral contracts have been
adopted in Java, Haskell, C\#, Python, Racket, Elixir
\cite{DBLP:conf/erlang/0001BBHMEF22}, etc. \note{cite}
Studies \cite{DBLP:conf/rodin/Chalin06, DBLP:books/ph/Meyer97}
have shown that behavioral contracts can effectively support design, development,
testing, and debugging of software systems.

In this paper, we develop the first behavioral contract system \lang (Contract
Solidity) for the Solidity language, providing a practical specification and
monitoring system for both first-order and higher-order behaviors.
%monitoring system for both \emph{higher-order and temporal behaviors}.
Solidity is a programming language to build smart contract programs that run on
the Ethereum platform.  As one of the most popular ecosystems of smart
contracts, Solidity has been used \todo{to do cool things}.
\todo{explain challenges}

%\lang enriches the Solidity language with \emph{higher-order} and
%\emph{temporal} behavioral contracts, which are absent in existing approaches.
%With higher-order and temporal behavioral specification, many downstream
%tasks become further amenable, including but not limited to static verification,
%guided testing, or specification extraction.

%However, Solidity and its running platform Ethereum is a complex system.
%Carelessly written contracts can cause serious bugs and loses.
%We identify \todo{solidity's tricky feature}

\subsection*{\textbf{Contracts for Address}}

One type of value in Solidity that exhibits higher-order behaviors is \emph{addresses}.

capability

\todo{restrict possible call targets}
\todo{why static verification fails}

\subsection*{\textbf{Monitoring Extent}}

extent

%\subsection*{\textbf{Contracts for Temporal Properties}}

%Temporal contracts provides a way to \todo{...}.

\subsection*{\textbf{Evaluation}}

Compared to existing approaches \todo{of what}, our work is both expressive,
easy-to-use, lightweight, effective, and economical.
Programmers can use all Solidity expressions to define the desired property,
which are attached only to relevant functions in a non-intrusive way.

We demonstrate that \lang is an effective approach to improve the robustness
and quality of smart contract programs.
By examining several cases of existing vulnerabilities, we show that our
approach is effective in preventing these attacks.
\zz{Let's mention the amount of funds we could save if we can prevent these attacks.}
We also evaluate the overhead (gas consumption) of our approach compared to
manually inserted assertion checks, showing that \todo{...}

\todo{why static verification fails}

%We develop a core model of \lang, including its syntax, operational semantics,
%and discuss its soundness guarantee.

%\todo{discuss performance/gas consumption}

%\todo{allows interesting programming idioms to be expressed}

% second-class contracts

\paragraph{Contributions} This paper makes the following contributions:
\begin{itemize}
  \item We design \lang, the first extension for Solidity that allows programmers to
        specify and enforce higher-order behaviors in smart contracts.
        We demonstrate \lang's use cases through extensive examples and
        implement \lang as a preprocessor for ordinary Solidity programs.
  \item We present the core formalization \lang, including its syntax, formal
        semantics, compilation, and soundness.
  \item We examine a number of real-world attacks with \lang, showing that our
        approach is effective in improving safety and reliability of smart contract
        programs.
  \item We evaluate the overhead of \lang compared to manually implemented
        assertions and checks, showing that our approach does not introduce
        additional runtime overhead.
\end{itemize}

\lang is open-sourced and publicly available at \note{url}.

