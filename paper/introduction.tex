\section{Introduction}
\label{sec:intro}

%https://se.inf.ethz.ch/~meyer/publications/old/dbc_chapter.pdf
%https://docs.soliditylang.org/en/v0.8.17/control-structures.html?highlight=require#panic-via-assert-and-error-via-require

%\todo{why? solidity is rather flexible, unsatisfying/weaker type system,
%not all invariants can be checked statically, e.g. the status of the chain}
%One \note{common} use case of higher-order functions in smart contracts is
%to express callback \todo{explain how it is used}.

%\todo{it is hard to enforce properties when callbacks exist}
%Static verification cannot completely address the issue here since
%transaction developers are oblivious to the user-provided callback.

%Building trustworthy and secure smart contract programs requires solid
%understanding and reliable enforcement of program invariants.

Smart contracts are programs to automate the execution of agreement so that all
parties involved in the agreement can be certain about the outcome.
Smart contracts are ``smart'' since by using blockchains they provide a
mechanism to \emph{ensure the economic outcome of transactions} without a
central authority.
A blockchain implements a consensus protocol of Byzantine-fault-tolerant
distributed ledgers.

It is however ironic that many popular smart contract languages, which hold the
great promise to ensure transactional outcomes via consensus and distributed
ledgers, do not provide enough means to \emph{ensure the computational outcomes}.
This unfortunate reality leads to poor quality of programs.
Without ensuring the quality of programs, it is impossible to ensure the
economic outcome of transactions.

Indeed, in recent years, we have seen a number of failures of smart contract
systems due to attacks utilizing vulnerable contract programs.
For example, in the famous DAO hack\note{cite}, the attacker is able to utilize the
callback mechanism to create recursive function calls and temporarily stole
money, causing a total lose of \$50 million.
The root cause of this attack is that the contract does not deploy defensive
checks before performing critical actions.

%\zz{ On the other hand, assertion primitives are crucial for ensuring the
%accuracy and integrity of a smart contract's business model. }
%\zz{ I'm not sure if this statement applies to the PL community, but from my
%understanding, assertions are typically used during testing rather than
%runtime.  However, in smart contracts, these assertions function as guard
%conditions and can cause reverts if violated, making them extremely important. }

%Solidity also provides the @modifier@ mechanism that intercepts
%before and after a function call, thus can be used to check
%pre- and post-conditions.
%\todo{can we compose modifier?}
%\todo{can we attach modifier to callbacks?}
%\todo{can we use modifier to check function's argument?}

We observe that popular smart contract languages (such as Solidity) do
not provide \emph{rich, effective, convenient} means to specify and enforce
contract behaviors.
Simple first-order assertion primitives (e.g., @require@) are indeed common,
but they cannot effectively check callable addresses or function values, which
are a common pattern used in smart contract programs.
Moreover, many of the critical behavior in smart contracts are \emph{temporal}.
For instance, the defense to the DAO attack \note{cite} is to
prevent ``reentrancy'' via external functions, which requires that the function
of interest cannot be invoked \emph{before} the current call of this function is finished.

The lack of sufficient linguistic means to specify and enforce subtle but
critical behaviors discourages programmers to use concise higher-level
abstractions when writing smart contract code.
Instead, to be secure, programmers are obliged to write verbose code with
lower-level or no abstractions, which conflates the main business logic with
behavioral checks, further leading to poor readability and maintainability.
For example, a common way to implement ``reentrancy guards'' is to manually
make an additional boolean state, marking if the function is finished.
And often worse, defensive checks can be easily forgotten or disregarded,
leading to vulnerable code causing real monetary lose.

%Apart from the investigating effort to certify and verify smart contract
%programs, language designers are responsible to empower programmers with better
%linguistic solutions to secure smart contracts in the first place.
In this paper, we develop practical \emph{behavioral
software contracts} that provide a lightweight solution for securing
\emph{smart contracts}. In particular, we develop a specification language and
monitor for higher-order and temporal behaviors in the Solidity language.

\subsection*{\textbf{Behavioral Contracts for Smart Contracts}}

Behavioral contracts provide a mechanism for programmers to specify assumptions
and guarantees of software components. The specified assumptions and guarantees
will be monitored and reported when violated.
Pioneered by the Eiffel language \cite{DBLP:books/ph/Meyer91} and the
Design-by-Contract methodology \cite{DBLP:conf/tools/Meyer98a}, behavioral
contracts have been widely adopted in Java, Haskell, C\#, Python, Racket,
Elixir \cite{DBLP:conf/erlang/0001BBHMEF22}, etc. \todo{cite}

\todo{why BC is good here?}

At the conceptual level, behavioral contracts is complementary to smart
contracts, in the sense that they are both agreement -- between software
components for the former, and between transactional parties for the later.
Thus, the two terms ``contract'' indeed mean the same thing but just different
levels of enforcement.

In this work, we design and implement a practical extension of Solidity, the
most popular language for building smart contract programs. The extension
enriches the Solidity language with \emph{higher-order} and \emph{temporal}
behavioral contracts, which are absent in existing approaches.
\todo{allows furthermore downstream tasks, fuzzing, static verification,
	natural language to formal spec etc.}

\subsection*{\textbf{Contracts for Callable Addresses and Higher-Order Functions}}

Higher-order contracts provides a way to specify and enforce pre- and
post-conditions of untrusted functions. \todo{...}

\todo{restrict possible call targets}
\todo{why static verification fails}
\zz{address vs. function call?}

\subsection*{\textbf{Contracts for Temporal Properties}}

Temporal contracts provides a way to \todo{...}.
\todo{why static verification fails}

We develop a core model of the extension, including its syntax,
operational semantics, and discuss its soundness guarantee.
With this extension of higher-order temporal behavioral contracts, we examine
several cases of reported bugs and vulnerabilities and show that
our approach is effective in preventing these attacks.
\zz{Let's mention the amount of funds we could save if we can prevent these attacks.}
We also evaluate the overhead (gas consumption) of our approach
compared to manually inserted assertion checks, showing that \todo{...}

%\todo{discuss performance/gas consumption}

%\todo{allows interesting programming idioms to be expressed}

% second-class contracts

\subsubsection*{\textbf{Contributions}} This paper makes the following contributions:
\begin{itemize}
  \item We design \lang, an extension for Solidity that allows programmers to
        specify and enforce higher-order and temporal behaviors in smart contracts.
        We demonstrate \lang's use cases through extensive examples and
        implement \lang as a preprocessor for ordinary Solidity programs.
	\item We present the core formalization $\lambda_\lang$ for our proposed
	      extension, including its syntax, formal semantics, compilation, and
	      soundness.
  \item We examine a number of real-world attacks with \lang, showing that our
        approach is effective in improving safety and reliability of smart contract
        programs.
  \item We evaluate the overhead of \lang compared to manually implemented
        assertions and checks, showing that our approach does not introduce
        additional runtime overhead.
\end{itemize}
\lang is open-sourced and publicly available at \note{url}.

