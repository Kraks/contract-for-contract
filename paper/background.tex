\section{Background: The Solidity Language}

We provide a brief introduction of Solidity first, then discuss our extension
of behavioral contracts.

brief introduction of the Solidity language, why it is complicated

address: they are callable and can perform arbitrary computation, but we cannot always
inspect the computation other than checking the underlying numeric addressing value.

\paragraph{Challenges}
Here we identify some major challenges imposed by the unique features of the
Solidity language and blockchain computation:

\begin{itemize}
  \item Rich higher-order computation:
    e.g., address are \emph{opaque first-class values carrying higher-order
    computation}.
  \item Distributed execution model:
    contracts are deployed on the blockchain and invoked remotely by an unknown
    or adversarial party.
  \item Open-world assumption:
    we do not have access and control of all smart contract programs.
  \item Efficiency requirement:
    deployed smart contract programs consumes ``gas'' and it is desirable
    to minimize gas consumption.
\end{itemize}

These challenges make it impossible to monitor all communication channels,
which further demands us exploring different design choices when layering
a specification and runtime monitoring system for Solidity.


