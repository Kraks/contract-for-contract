
\subsection{Contracts for Temporal Behaviors}

Temporal contracts relate two function calls (events) and enforces their
relation.
They can inspect the time-stamps, message sender, arguments, return values
of the two function calls.

\todo{where to add message sender? proposed syntax:}
\begin{lstlisting}
  # ts1 \code{ f(x) returns z from sdr1 => ts2 } g(a) returns c from sdr2
\end{lstlisting}
\begin{lstlisting}
  # f(x) returns z => g(a) returns c /\ f.msg.sender == g.msg.sender
\end{lstlisting}
\wac{\texttt{msg.sender} is better tied with transaction. We can use ts1.msg.sender and I prefer to put the constraints in the side-cond. }

\subsubsection{Positive Temporal Properties}

Positive temporal properties enforces that an event must happen
after another event. Syntax:
\begin{lstlisting}
  # ts1 \code{ f(x) returns z => ts2 } g(a) returns c /\ side-cond
\end{lstlisting}
It enforces that when \code{g} is invoked, we check \code{f} has invoked \emph{and}
the side-condition is evaluated to true.
We do not enforce that \code{g} will be invoked eventually after invoking \code{f}.

Side conditions can be arbitrary expressions that uses the time-stamps, message
sender, arguments, return values of the two function calls.
For example, the following spec passes arguments of \code{f} and \code{g} into
another function for checking:

\begin{lstlisting}
  # ts1 \code{ f(x) returns z => ts2 } g(a) returns c /\ check(x, a)
\end{lstlisting}

If a variable occurs in both events, an additional equality constraint
is synthesized.  For example,
\begin{lstlisting}
  # ts1 \code{ f(x) returns z => ts1 } g(z) returns c
\end{lstlisting}
requires that both function \code{f} and \code{g} happen in the same transaction,
and the return value of \code{f} is the same as the argument of \code{g}.
It will be translated to the core syntax as the following:
\begin{lstlisting}
  # ts1 \code{ f(x) returns z => ts2 } g(y) returns c /\ ts1 == ts2 && x == y
\end{lstlisting}

It is totally fine to omit the time-stamp, arguments, or return values.
Simply requiring \code{f} happens before \code{g}:
\begin{lstlisting}
  # f => g
  function f(...) { ... }
\end{lstlisting}

\todo{need to think about quantification.}

Note: \code{f => g} matches the most recent call of \code{f},
or any prior call of \code{f} (if there are multiple calls of \code{f})?

\todo{need to think about interactions with compiler optimization (eg inlining).}

\todo{need to think about how temporal contracts interact with address calls.}

\subsubsection{Negative Temporal Properties}

Negative temporal properties enforces that an event must \emph{not}
happen after another event.

\begin{lstlisting}
  # ts1 \code{ f(x) returns z =/> ts2 } g(a) returns c /\ side-cond
\end{lstlisting}
It enforces that when \code{g} is invoked \emph{and} the side condition
evaluates to true, we check that \code{f} has not been invoked.

We do not enforce that \code{g} cannot be invoked eventually
after invoking \code{f}.

For example, the following spec enforces that \code{g} cannot be
invoked after \code{f} using \code{z} as the argument:
\begin{lstlisting}
  # ts1 \code{ f(x) returns z =/> ts2 } g(z) returns c
  //or equivalently
  # ts1 \code{ f(x) returns z =/> ts2 } g(y) returns c /\ x == y
\end{lstlisting}
However it is okay to call \code{g} after \code{f} with an argument different from \code{z}.

\subsubsection*{Affine Use}

Using negative temporal contracts, we can enforce affine use, i.e.
a function can be called at most once.
\begin{lstlisting}
  # f =/> f
  function f(int x) { ... }
\end{lstlisting}
If \code{f} has been called before (and the call is finished), any
call to \code{f} afterwards is prohibited.

\note{could further discern different timestamps/senders}

%linear (must call once),
%relevant (at least call once)

\subsection{Contextual Properties}

Contextual contracts inspect the calling-context/stack within the
current smart contract.

\note{Related work: stack inspection. But we don't need to modify the runtime
	of EVM, but simply record a shadow stack for necessary metadata. Is that enough?}

\subsubsection{Positive Contextual Properties}

For example, the following spec enforces that \code{g} can only be invoked
under the calling context of \code{h}, and the return value of \code{h} must be
the same as the argument of \code{g}:

\begin{lstlisting}
  function h(int x) returns int { ... }
  # h(x) returns y ~> g(y) returns r
  function g(int y) returns int { ... }
\end{lstlisting}

To enforce this behavioral contracts, we must check
\begin{itemize}
	\item when \code{g} is invoked, there is a frame of \code{h} on the stack,
	\item when \code{h} returns (which happens after \code{g} returns), the return value
	      is the same as the argument of \code{g}.
\end{itemize}

Question: what if \code{g} is invoked multiple times under the same calling context of
\code{h}?

Solution: need quantifier. A simple/default solution is to check all
invocations of \code{g}.

Question: what if there are multiple call frames of \code{h} on the stack?

Solution: need quantifier. A simple/default solution is to only check
the most recent call frame of \code{h} on the stack.

\wac{I think the previous definition of contextual property $h ~> g$ means $\forall g, \exists h$ implicitly, i.e., for any $g$ called, there must exist one $h$ on the call stack. I cannot think of a use scenario where quantifiers on $h$ and $g$ are needed in practice.}
\wac{If we want to distinguish different call frames of $h$ and $g$, maybe it's better to design activation constraints for the contextual properties, e.g., \texttt{cond -> h ~> g}, meaning $h ~> g$ is only enforced when $cond$ is true (imply). ps: the special arrow is broken outside the listing environment. :(}

\subsubsection{Negative Contextual Properties}

The following program is a violation of non-reentrancy:

\begin{lstlisting}
  # non-reentrant
  function f(uint x) { f(n) }
\end{lstlisting}

This is an example of negative contextual properties, i.e. something cannot
happen under the current calling context. Under the neath, this spec is
equivalent to

\begin{lstlisting}
  # f ~/> f
  function f(uint x) { f(n) }
\end{lstlisting}

