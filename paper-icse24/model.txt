# syntax

x, f, c âˆˆ <id>

type := int
      | uint
      | boolean
      | address
      | mapping (T => T)
      | struct x { T x; ... }

mod := public | private // omitting external and internal

opt_decl := { (<id> : <id>)* }

spec := <id>[<opt_decl>](<id>*) returns (<id>*)
        requires <expr> ensures <expr> where <spec>*

decl := <type> <id>

fun_def = function f(<decl>*) returns (<type>*) { <stmt>; }

fun := <spec> <fun_def>

con := contract c { <decl>*; <fun>* }

value := int âˆª uint
       | true
       | false
       | <id>'('<value>*')'

opt := '{' (<id> : <expr>)* '}'

expr := <id>
      | <value>
      | <expr> op <expr>
      | <expr>'.'<id>[<opt>]'('<expr>*')'

s := <stmt>; <stmt>
   | <expr>
   | <decl> = <expr>
   | <id> = <expr>
   | if (<expr) { <stmt> } else { <stmt> }
   | return <expr>

# static semantics

well-defined consol specification
type checking semantics

judgment: Î“ âŠ¢ <fun> OK

    Î“, x: t1 âŠ¢ pre : boolean
    Î“, x : t, y: t2 âŠ¢ post : boolean
    spec are of type address
    spec recur
-----------------------------------------------------------------
Î“ âŠ¢ f(ğ‘¥) returns (ğ‘¦) requires pre ensures pos where specs
    function f(ğ‘¤: t1) returns (t2) { body }

# translation semantics


