\section{Related Work} \label{sec:related}

% \subsubsection*{\textbf{Behavioral Contracts and Runtime Verification}}
\bfpara{Behavioral Contracts.}
The Eiffel programming language pioneered the ``design-by-contract'' methodology \cite{DBLP:books/ph/Meyer91, DBLP:conf/tools/Meyer98a}, 
advocating the idea of setting clear expectations between software components 
right at the outset of software development.
\citet{DBLP:conf/icfp/FindlerF02} proposed to extend the notion of behavioral contracts 
to higher-order functions.
\lang borrows ideas from contracts for higher-order functions to monitor
address specifications, given their same higher-order essence.
An interesting future work of \lang is to extend it with higher-order temporal contracts \cite{DBLP:conf/icfp/DisneyFM11},
which would be particularly useful for smart contract programs.
%While our work, in its current iteration, focuses on first-order and higher-order behaviors of smart contracts, we anticipate the foundational endeavor paves the way for consideration of more expressive behaviors.

\iffalse
This is most related to a security mechanism called stack inspection, which is implemented in systems like \texttt{Java} to prevents access from untrusted components to resources protected by trusted components \cite{DBLP:conf/popl/FournetG02, DBLP:conf/sp/WallachF98}. 
However, \lang propagates address specifications down the stack and performs check at call sites while stack inspection inspects the entire call stack before accessing certain resources.
\fi

\iffalse
袁老板related work写得太好了不忍心删 hhh
The landscape of behavioral contracts has seen notable advances over the past decades.
Arguably one of the pioneering efforts in assertion-based contracts is 
the ``design-by-contract'' methodology \cite{DBLP:books/ph/Meyer91, DBLP:conf/tools/Meyer98a} 
as realized in the \texttt{Eiffel} programming language. 
It advocates the idea of setting clear expectations between software components 
right at the outset of software development.
Pushing the boundaries, \texttt{DrScheme} incorporates an assertion monitoring system 
to support contracts for higher-order functions \cite{DBLP:conf/icfp/FindlerF02}.
%
To support temporal contracts on top of higher-order contracts, \citet{DBLP:conf/icfp/DisneyFM11} formalizes the behavior of imperative higher-order functions as a sequence of events, namely calls to other functions and the matching returns, and imposes the delineated contracts over the event sequences.
%
More recently, a behavioral contract, drawing inspiration from a static "size-change" termination verification approach \cite{DBLP:conf/popl/LeeJB01}, is developed to enforce termination \cite{DBLP:conf/pldi/NguyenGTH19}, which otherwise cannot be checked directly during runtime as a canonical liveness property.
%
% a form of liveness properties, i.e. something good will happen eventually.
% This work only considers safety property, i.e. monitoring and preventing something bad will not happen.


\lang not only takes inspiration from these prior works but also proposes a distinct feature -- persistent monitoring of address specifications.
Recall that smart contract is a domain where programs have direct economic outcome but often suffers from attacks due to its open-world distributed nature. \lang provides programmers a convenient way to specify the intended behavior of external functions, which otherwise is beyond their control.
% \lang also stands out among other behavioral contract system in its unique handling The distinct nature of smart contracts compared to normal programs poses real-world challenges that \lang tackles through its specification monitoring system, as discussed throughout the paper.
%
% Notably, by attaching specification to address values, \lang is able to enforce checks upon entry and exit of external functions, which is beyond programmers' control.
%
This is most related to a security mechanism called stack inspection, which is implemented in systems like \texttt{Java} to prevents access from untrusted components to resources protected by trusted components \cite{DBLP:conf/popl/FournetG02, DBLP:conf/sp/WallachF98}. 
%
However, \lang propagates address specifications down the stack and performs check at call sites while stack inspection inspects the entire call stack before accessing certain resources.

While our work, in its current iteration, focuses on first-order and higher-order behaviors of smart contracts, we anticipate the foundational endeavor paves the way for consideration of more expressive behaviors.
% A closely related work to our temporal contracts and monitoring is interface automata \cite{DBLP:conf/sigsoft/AlfaroH01}.
\fi

% \subsubsection*{\textbf{Smart Contracts}}



% survey \cite{DBLP:journals/csur/TolmachLLLL22}
% core calculus of Solidity-like languages \cite{DBLP:conf/sp/JiaoK0S0020, Sergey2021, DBLP:conf/esorics/BartolettiGM19, DBLP:conf/fc/CrafaPZ19}
\bfpara{Smart Contracts.}
%Researchers have made efforts to securing smart contracts from many aspects.
Runtime validation of smart contracts is the most relevant direction to \lang.
\citet{DBLP:conf/pldi/LiCL20} propose a technique to translate user specified 
contract-level invariants into solidity code via delta update and delta check.
\citet{chen2022declarative} propose a declarative smart contract language, 
which also inserts runtime checks after compilation.
\citet{DBLP:conf/edcc/EllulP18} propose violation resolution procedures in runtime verification when specifications are violated.
In contrast, \lang provides finer-grained property checking with function-level checks and persistent address monitoring.

Orthogonal to \lang, static analysis and verification of smart contract programs are intensively studied.
\citet{DBLP:journals/csur/TolmachLLLL22} survey the use of formal specification and verification techniques
in securing smart contracts.
Statically checked refinement types \cite{coblenzObsidianSaferBlockchain2017,DBLP:journals/pacmpl/TanMLDF22}
allow developers to write specifications as part of types.
\citet{DBLP:journals/pacmpl/BramEMSS21} propose a specification methodology to 
capture the intended behaviors of contracts under development, as well as external 
unverified contracts.
\cite{DBLP:journals/pacmpl/GrossmanAGMRSZ18} works only on callback-related vulnerabilities that \lang can effectively prevent.
Researchers have also proposed works mining high-level semantics from contracts~\cite{liu2022finding,liu2022invcon}.
Recent studies have also focused on modeling Solidity semantics
\cite{DBLP:conf/sp/JiaoK0S0020, Sergey2021, DBLP:conf/esorics/BartolettiGM19, DBLP:conf/fc/CrafaPZ19}, and analyze flaws and vulnerabilities using pre-defined oracles~\cite{DBLP:journals/pacmpl/SmaragdakisGLTT21,DBLP:journals/pacmpl/GrechKJBSS18, DBLP:conf/pldi/Pirlea0S21, ghaleb2022etainter,liao2023smartstate, DBLP:journals/pacmpl/AlbertGRRRS20, DBLP:conf/pldi/BrentGLSS20}, focusing on aspects such as insecure payment~\cite{DBLP:journals/pacmpl/WangZS19}, 
% gas-related~\cite{ghaleb2022etainter}, 
and access control~\cite{ghaleb2023achecker}.
% , and callback~\cite{DBLP:journals/pacmpl/AlbertGRRRS20}, and composite vulnerabilities~\cite{DBLP:conf/pldi/BrentGLSS20}.
% Moreover, several empirical studies 
% \cite{renEmpiricalEvaluationSmart2021,durieuxEmpiricalReviewAutomated2020,DBLP:conf/icse/ZhangZXL23,DBLP:journals/tse/ZhangWCLLLL23} 
% have been conducted to evaluate contract analysis techniques.
% Compared to static approaches, 
In contrast, \lang is a programmer-oriented language extension and supports expressive specifications to conduct runtime verification.
% allows developers to express specifications that are checked at runtime.

% Solythesis~\cite{DBLP:conf/pldi/LiCL20}, leveraging delta instrumentation strategy, conducts runtime validation with little overhead, focusing only on contract-level global invariants. 



% \todo{recent se work}


% \xx{----split---}

% SPCon\cite{liu2022finding}, static (role mining) and dynamic detects potential permission bugs 

% InvCon \cite{liu2022invcon} dynamic invariant detection

% \cite{zheng2023turn} limitations of existing reentrancy detection tools (false positive), only detect call.value()

 % \cite{ghaleb2022towards} study show limitations (false positive), propose a static tool to reduce fp

 
% DeCon~\cite{chen2022declarative},  a declarative programming language specifying contract-level properties

% runtime verification \cite{DBLP:conf/edcc/EllulP18}
% runtime validation, reduce overhead of runtime checks \cite{DBLP:conf/pldi/LiCL20}

% Harvey: greybox fuzzer ~\cite{wustholz2020harvey}: gen transaction seq, and fuzz on seq

% ItyFuzz~\cite{shou2023ityfuzz} snap-shot based. identify state, dataflow analysis. 

% Smartian~\cite{choi2021smartian} fuzzing via static + dynamic data flow analysis


% SmartDagger~\cite{liao2022smartdagger} static, cross-contract vulnerability detection

% \cite{ren2021making} effort to make Smart Contract Development More Secure and Easier via better code-suggestion algo, integrating testing tool,

% MANDO-GURU~\cite{nguyen2022mando}, DL-based vul detection (call graph and control flow graph)
% security analyzer \cite{DBLP:conf/pldi/BrentGLSS20} detect composite information flow violations (static)

% nondeterminisitic payment bugs \cite{DBLP:journals/pacmpl/WangZS19} with information flow tracking (static)

% behavioral simulation to verify smart contracts \cite{DBLP:conf/pldi/BeillahiCEE20}

% formal and modular specification of smart contracts \cite{DBLP:journals/pacmpl/BramEMSS21}

% refinement types \cite{DBLP:journals/pacmpl/TanMLDF22}

% static analysis to infer ownership and commutativity summaries, for parallelism \cite{DBLP:conf/pldi/Pirlea0S21}

% callbacks \cite{DBLP:journals/pacmpl/AlbertGRRRS20, DBLP:journals/pacmpl/GrossmanAGMRSZ18} (1.static 2. static + dynamic)

% reduce gas consumption 
% gas-focused vulnerabilities (exploit undesired behavior when a contract runs out of gas) via control-flow analysis-based decompiler\cite{DBLP:journals/pacmpl/GrechKJBSS18}

% static analysis of Ethereum \cite{DBLP:journals/pacmpl/SmaragdakisGLTT21}


