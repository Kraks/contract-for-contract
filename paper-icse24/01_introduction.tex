\section{Introduction} \label{sec:intro}

%https://se.inf.ethz.ch/~meyer/publications/old/dbc_chapter.pdf
%https://docs.soliditylang.org/en/v0.8.17/control-structures.html?highlight=require#panic-via-assert-and-error-via-require

%\todo{why? solidity is rather flexible, unsatisfying/weaker type system,
%not all invariants can be checked statically, e.g. the status of the chain}
%One \note{common} use case of higher-order functions in smart contracts is
%to express callback \todo{explain how it is used}.

%\todo{it is hard to enforce properties when callbacks exist}
%Static verification cannot completely address the issue here since
%transaction developers are oblivious to the user-provided callback.

%Building trustworthy and secure smart contract programs requires solid
%understanding and reliable enforcement of program invariants.

Smart contracts are programs to automate the execution of transactional agreements, ensuring that all involved parties align in their expectations of the outcome. 
% to automate the execution of transactional  agreements so that all parties involved in the agreement can be certain  about the outcome.
% Deployed on blockchains, immutable and distributed ledgers~\cite{nakamoto2008bitcoin}, these programs 
% uphold the principles of 
% immutable, distributed ledgers~\cite{nakamoto2008bitcoin}, and 
% Smart contract 
Smart contract programs are ``smart'' as they
% since they are programs to 
% therefore  
\emph{ensure the economic outcome of transactions} by running on decentralized blockchains, 
implementing a consensus protocol of immutable, distributed ledgers \cite{nakamoto2008bitcoin}.
% By using blockchains,
Since transactions cannot be amended or revoked once finalized on the blockchain,
the reliability of smart contract programs is of vital importance, especially
for those involving financial or monetary operations.
%Due to the immutability of transactions,
% , these smart contracts, 
%once deployed\todo{another word}, they cannot be amended or undone. 
%Given that smart contracts are extensively utilized in financial operations, their reliability and security are of vital importance. %\xx{revised}
%\xx{no reverse back + transactions, therefore the reliability and security of smart contracts are of vital importance..}


It is however ironic that despite the potential of smart contracts,
\emph{languages} writing smart contracts often lack adequate mechanisms to \emph{ensure the
computational outcomes}. This unfortunate reality results in an unsatisfactory
quality of smart contract programs. Without proper means to ensure the quality
of these programs, the aspiration to ensure the economic outcome of
transactions remains nothing more than a mere wish.

Undoubtedly, the past few years have witnessed several catastrophic failures
of blockchain systems resulting from attacks on vulnerable contract programs \cite{DBLP:conf/icse/ZhangZXL23}.
One prominent instance is the well-known DAO hack~\cite{DAOhack} where an unauthorized
attacker exploited recursive function calls and callback mechanisms, leading
to a staggering loss of \textdollar50 million. The fundamental issue at the core of this
attack on deployed contracts was the failure to prevent reentrancy under certain 
critical conditions.

%\zz{ On the other hand, assertion primitives are crucial for ensuring the
%accuracy and integrity of a smart contract's business model. }
%\zz{ I'm not sure if this statement applies to the PL community, but from my
%understanding, assertions are typically used during testing rather than
%runtime.  However, in smart contracts, these assertions function as guard
%conditions and can cause reverts if violated, making them extremely important. }

%Solidity also provides the @modifier@ mechanism that intercepts
%before and after a function call, thus can be used to check
%pre- and post-conditions.
%\todo{can we compose modifier?}
%\todo{can we attach modifier to callbacks?}
%\todo{can we use modifier to check function's argument?}

\iffalse
\begin{figure}[t]
\begin{lstlisting}[numbers=left,stepnumber=1,xleftmargin=1em,numberstyle=\ttfamily\color{gray},numbersep=3pt]
interface IERC20 {
  function transferFrom(address, address, unit);
}
contract Vault {
  address owner;
  constructor() { owner = msg.sender; }
  function deposit(address token, uint amount) public {
    require(msg.sender == owner);
    IERC20(token).transferFrom(msg.sender, 
      address(this), amount);
  }
}
\end{lstlisting}
\caption{A simplified example using addresses. \note{GW: this is an important example, mentioned in sec 1/2/3, should think about ways to improve}
\todo{GW: DAO?} \todo{GW: explain this with more details}
}
\label{fig:intro_example}
\end{figure}
\fi

To prevent such attacks, programmers need to specify those critical
conditions. The execution is allowed only when those conditions are met.
However, we observe that existing popular smart contract languages (e.g.,
Solidity) do not provide \emph{expressive, effective, and convenient} means to
\emph{specify} and \emph{enforce} contract behaviors.
Static verification techniques have been intensively investigated (e.g. \cite{DBLP:journals/pacmpl/AlbertGRRRS20,
DBLP:journals/pacmpl/SmaragdakisGLTT21, DBLP:journals/pacmpl/SmaragdakisGLTT21, DBLP:journals/pacmpl/TanMLDF22}),
but they are often expensive or imprecise \cite{rice1953classes} to use in practice.
Run-time validations such as simple assertions of primitive data are available, 
but they are inconvenient to use and ineffective at 
% they are neither convenient to use, nor can effectively 
examining values carrying computational content. % \xx{cite and example}. 
For example, callable addresses and functions, as common patterns used in developing
smart contract programs, introduce higher-order behaviors \emph{when used as arguments} %\xx{example, explain figure with details}
(\Cref{fig:sturby_buggy} for an example) and often exhibit elusive vulnerabilities. % \xx{example}. 
%Moreover, many of the critical conditions in smart contracts are \emph{temporal}
%-- the order of events matters.
%For instance, to defense the DAO attack caused by reentrancy via
%external functions, it requires to check that the function of interest cannot
%be invoked \emph{before} the current call of the same function is finished.

%\xx{without effective tools or proper ways, developers tend to write error-prong assertions which are inconvenient. This urges the need to have sufficient linguistic means to provide expressive, effective and convenient way to guard the contracts and xxx. However, they do not exist. }

The lack of \textit{sufficient  linguistic means} to modularly specify and enforce 
subtle and critical behaviors discourages programmers from writing clean and maintainable
code with higher-level abstractions.
Instead, programmers are obliged to meticulously write verbose low-level code (e.g. assertions)
to implement defensive checks. These checks are interspersed with the main business logic,
 leading to poor readability and maintainability 
(\Cref{fig:sturby_buggy}).
%The pervasive temporal conditions in distributed blockchain systems further
%complicates the situation: these temporal behavioral checks are usually
%encoded as value-level checks in ad-hoc manners.
%Taking the DAO attack as example again, a common way to implement ``reentrancy
%guards'' is to manually define an additional boolean flag, indicating
%whether the function is finished. This is both verbose and error-prone,
%quickly becoming unmanageable for complex behaviors.
Often worse, defensive checks are neglected, resulting in
vulnerable code causing real monetary loss.
%\todo{DX: need a concrete motivating example?}
% GW: yes

%Apart from the investigating effort to certify and verify smart contract
%programs, language designers are responsible to empower programmers with better
%linguistic solutions to secure smart contracts in the first place.
% \subsubsection*{\textbf{Raise the Level of Expressiveness}}
\bfpara{Raise the Level of Expressiveness.}
To address these issues, we argue that \emph{behavioral software
contracts}~\cite{DBLP:conf/tools/Meyer98a} should play a fundamental role in
the development of reliable \emph{smart contract} programs.
As a metaphor, ``behavioral contracts'' specify assumptions and guarantees 
between software components, just as ``smart contracts'' specify assumptions and guarantees 
between business parties.
The two notions of ``contract'' should complement each other.
%\xx{why is this similarity important?}

Behavioral contracts are an expressive and convenient tool for programmers since assumptions (pre-conditions) and guarantees (post-conditions)
are specified as executable specifications, written in the same programming language syntax.
%\xx{therefore offers convenient and expressive ways to ..(why appealling)}.
At run-time, violations of these conditions are monitored and reported.
Studies \cite{DBLP:conf/rodin/Chalin06, DBLP:books/ph/Meyer97}
have shown that behavioral contracts can effectively support design, development,
testing, and debugging of software systems.
Pioneered by the Eiffel language \cite{DBLP:books/ph/Meyer91},
programmers have embraced the design-by-contract methodology \cite{DBLP:conf/tools/Meyer98a,
DBLP:books/ph/Meyer97} to build high-assurance software in various languages 
with extensions of behavioral contracts,
e.g., Java \cite{DBLP:journals/sttt/BurdyCCEKLLP05},
C++ \cite{boost_contract},
Python \cite{icontract},
Haskell \cite{DBLP:conf/popl/XuJC09},
Racket \cite{DBLP:conf/icfp/FindlerF02},
Elixir \cite{DBLP:conf/erlang/0001BBHMEF22}, etc. 

Unfortunately, such expressive tools for smart contract programmers are not yet available. %\xx{to fill the gap}
In this paper, we offer the first behavioral contract system \lang \footnote{\emph{Con}tract \emph{Sol}idity, or, \emph{Con}solidating \emph{Sol}idity.}, providing a practical
specification and monitoring system for Solidity, the most widely-used smart contract language, of both  \textit{first-order} and \textit{higher-order} behaviors.
% for the most widely-used smart contract language, Solidity.
\begin{itemize}[leftmargin=0.3cm, topsep=1.5pt]
% [leftmargin=2em]
  \item \lang is \emph{non-intrusive}, i.e., it does not alter either static or dynamic behaviors of Solidity programs.
  \item \lang is \emph{effective}, i.e., it monitors violations of specified conditions for both top-level functions and address calls, regardless of how the address value flows in the program.
  \item \lang is \emph{expressive}, i.e., programmers can liberally write and enforce any computable properties.
  \item \lang is \emph{gradual}, i.e., programmers only write specifications when necessary.
  \item \lang is \emph{efficient}, i.e., incurring minimal monitoring overhead (gas consumption) at run-time.
\end{itemize}
\lang enables the development of smart contract programs that are more reliable, readable, and maintainable. 
% writing not only more reliable, but also more readable and
% maintainable smart contract programs.
We then discuss the two main features of \lang.
%\xx{the benefit of \lang is threefold. 1. effective for both first-order and higher-order and persistent monitoring on the addresses 2. expressive  (ANY properties) 3. convenient no need to learn new languages, and offers great readability and maintainability. }

%\lang enriches the Solidity language with \emph{higher-order} and
%\emph{temporal} behavioral contracts, which are absent in existing approaches.
%With higher-order and temporal behavioral specification, many downstream
%tasks become further amenable, including but not limited to static verification,
%guided testing, or specification extraction.

%However, Solidity and its running platform Ethereum is a complex system.
%Carelessly written contracts can cause serious bugs and loses.
%We identify \todo{solidity's tricky feature}

%Compared to existing approaches \todo{of what}, our work is both expressive,
%easy-to-use, lightweight, effective, and economical.

% \subsubsection*{\textbf{Behavioral Contracts for First-Order Values}}
\bfpara{Behavioral Contracts for First-Order Values.}
Programmers can attach pre- and  post-conditions 
to examine arguments, return values,  and side effects of the target functions. 
%\xx{?}\yy{side effect cannot be specified (yet)?}\note{GW: side effects can be observed/checked}
These conditions can be any Solidity expression of type Boolean.
%These conditions can take the form of any Boolean expression constructed in Solidity.
Conditions about first-order values,
% (e.g. numbers and primitive data) can be examined straightforwardly when the function is called or returned
such as numbers and primitive data, are examined at the time of the function invocation or return.
% -- they 
%These conditions can be translated to assertions that are checked before and after the execution of the function.

% \subsubsection*{\textbf{Behavioral Contracts for Higher-Order Values}}
\bfpara{Behavioral Contracts for Higher-Order Values.}
A more intricate data type in Solidity is \emph{address}, which is the focus of \lang.
Similar to pointers in other low-level languages, addresses are unsigned integers,
referring to an account or contract instance on the blockchain.
Unlike ordinary values, addresses carry computational contents, i.e., they embody 
callable functions.
Addresses are commonly used to implement callback in Solidity,
thus functions taking addresses as arguments can have more latent behaviors.
Therefore, it is necessary to regulate these addresses and functions with pre-/post-conditions.

In contrast to monitoring the specification of first-order values, 
which can be performed by assertions as the prelude and epilogue of function calls,
predicates of addresses (when used as arguments) cannot be checked in this way.
% it is not always possible to check\xx{enforce} the conditions\xx{spec} of addresses \emph{as arguments} in the same way.
%the validation of conditions for addresses, particularly when they are passed as arguments, cannot always be conducted in the similar manner. 
When an address $x$ is passed as an argument to a function $f(x)$, 
the latent arguments and return values \emph{of address call $x(\dots)$} is unknown at 
the time of $f$'s invocation (see \Cref{fig:sturbyIntro} for a detailed example).
% GW(2:20AM): I made a pass of this paragraph, I don't think we need to talk too much
% about the example, just referring to the right figure/section seems enough to me.
Therefore, it is \emph{undecidable} to check properties of $x$ when calling $f$.
%Consider the address call at line 3 of \Cref{fig:sturby_buggy}, although the address \code{steth}
%is an argument to \code{get}, it is \emph{undecidable} to check properties about
%the arguments and return values of \code{steth} when calling \code{get}.
Moreover, addresses are first-class citizens, i.e. they can be used
as function arguments, returned from functions, or stored in storage.
%\xx{this versatility poses a question: }
%\note{GW: interspersed with business logic}
This flexibility poses a challenge: when programmers specify conditions for address calls, 
when and how can they soundly enforce the specification of address values?

% Borrowing ideas from\xx{inspired by} 
\lang tackles this issue by borrowing ideas from behavioral contracts of higher-order functions \cite{DBLP:conf/icfp/FindlerF02}.
By using a whole-program transformation that designates a different
value representation of guarded addresses, \lang ensures 
that any violation within the current contract programs is monitored.
The persistent monitoring empowers programmers to write down the expected
behaviors of address calls in a clean way, without interspersing low-level checks
with business logic. 
% \xx{cha dian yi si}
%keeps the specification provenance along with the address value.
%\todo{say it is powerful to do what}
% \xx{more highlights. This design enables ....}
% \xx{explain the fig 1 example here?}

\input{fig_sturby_intro}

\iffalse
Using a core language that models the essence of Solidity, \Cref{sec:model} 
gives the static semantics and translation semantics of \lang, and discusses 
the soundness of our approach. We also  briefly describe the implementation of \lang.
\xx{too detail}
\fi

%\todo{restrict possible call targets}
%\todo{why static verification fails}

%\subsection*{\textbf{Contracts for Temporal Properties}}

%Temporal contracts provides a way to \todo{...}.

% \subsubsection*{\textbf{Effectiveness and Efficiency}}
\bfpara{Effectiveness and Efficiency.}
%\lang introduces a tool to facilitate the development of smart 
%contracts employing the design-by-contract methodology.
To evaluate the effectiveness and efficiency of \lang, we
examine \numCaseStudied real-world smart contract attacks (a total loss of \$8.1M) and their defenses (\Cref{sec:case}).
% These cases have resulted in a total loss of \$8.1M.
Our results show that these defenses (fixes) can be specified with a few 
lines of non-intrusive \lang specifications, and the generated programs are effective in preventing these attacks.
% at runtime our approach prevents the attack. 
%\note{one more detailed sentence}

To evaluate the gas consumption of our approach,
we patch the vulnerable contracts using 
both low-level assertions and \lang specifications, respectively, 
and evaluate the gas fee increase induced by the patches.
Results show that patching with \lang is comparably efficient as using assertions, only costing at most \$1.2 (avg. 0.98\%) more transaction fees.
We also evaluate the gas consumption of our approach 
compared to assertion checks that achieve the same effect on 
a dataset of contracts collected from previous work~\cite{DBLP:conf/pldi/LiCL20}.
%The additional gas consumption comes from the generated interposition layer.
Our results show that \lang exhibits on average 0.43\% higher overhead while offering 
significant enhancements in modularity, readability, and maintainability.

%\todo{discuss performance/gas consumption}

% \subsubsection*{\textbf{Contributions}} 
\bfpara{Contributions.}
This paper makes the following contributions:
\begin{itemize}[leftmargin=0.6cm, topsep=1.5pt]
% [leftmargin=2em]
  \item We introduce \lang, an extension for Solidity that empowers
        programmers to specify and enforce higher-order behaviors.
        We demonstrate \lang's design and use cases through extensive examples (\Cref{sec:examples}).
  \item We present the core formalization of \lang with its translation semantics (\Cref{sec:model}).
        We discuss its soundness by characterizing the extent of effective monitoring,
        providing a notion of when and where programmers can trust \lang.
  \item We implement \lang as a compiler that translates annotated 
        programs into ordinary Solidity programs (\Cref{sec:impl}). 
        We also discuss optimizations that do not induce additional storage overhead 
        in practice. %used in the practical implementation.
  \item We examine \numCaseStudied real-world attacks (\Cref{sec:case}), showing the effectiveness of \lang
        % is effective 
        in defending these attacks meanwhile exhibiting better readability.
        %including but not limited to SushiSwap~\cite{sushiSwapHack}, Dexible~\cite{dexibleHack}, EFLeverVault~\cite{levusdcHack}.
  \item We evaluate the efficiency of \lang-annotated programs compared to manually 
        implemented assertions using the 10 attacks and a dataset of previous study~\cite{DBLP:conf/pldi/LiCL20}, 
        showing that \lang only introduces up to 0.98\% more gas consumption (\Cref{sec:perf}).
        %\xx{the efficiency of \lang, including overhead, ....}
        
\end{itemize}
We discuss the motivation and challenges in \Cref{sec:background} and discuss
related work in \Cref{sec:related}.

\bfpara{Availability.} Our experiment results are available at~\cite{consolartifact}. 
% \lang is open-sourced and publicly available at \url{https://anonymized-link}.
% \todo{fill link}

% \lang is open-sourced and publicly available at \url{https://anonymized-link}.
